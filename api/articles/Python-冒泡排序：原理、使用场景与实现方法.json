{"title":"Python 冒泡排序：原理、使用场景与实现方法","uid":"5a1ed4bfdc47ff55e285206610294889","slug":"Python-冒泡排序：原理、使用场景与实现方法","date":"2024-02-09T08:11:13.000Z","updated":"2024-02-09T08:14:31.905Z","comments":true,"path":"api/articles/Python-冒泡排序：原理、使用场景与实现方法.json","keywords":null,"cover":[],"content":"<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法，因其运作机制类似于水中的气泡不断向上浮起而得名。虽然在实际应用中，冒泡排序通常不是最优选择，但其原理清晰易懂，常被用作学习和理解排序算法的基础，对于初学者有着重要的教育价值。</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif\" alt=\"冒泡排序\"></p>\n<h3 id=\"一、冒泡排序原理\"><a href=\"#一、冒泡排序原理\" class=\"headerlink\" title=\"一、冒泡排序原理\"></a>一、冒泡排序原理</h3><p>冒泡排序的基本思想是通过不断交换相邻两个元素的位置，使较大的元素逐渐“浮”到序列的末尾，每一轮循环都会将当前未排序序列中的最大（或最小）元素“冒泡”至正确位置。</p>\n<ol>\n<li><strong>比较并交换过程</strong>：从数组的第一个元素开始，每次遍历都将相邻的元素两两进行比较，如果前一个元素大于后一个元素，则交换它们的位置。</li>\n<li><strong>重复上述过程</strong>：每完成一次遍历（即一趟冒泡），最后一个元素将是当前未排序部分的最大值。因此，需要重复此过程n-1次，以确保整个数组完全有序。</li>\n</ol>\n<h3 id=\"二、冒泡排序步骤详解\"><a href=\"#二、冒泡排序步骤详解\" class=\"headerlink\" title=\"二、冒泡排序步骤详解\"></a>二、冒泡排序步骤详解</h3><p>假设有一个无序数组<code>[5, 3, 8, 6, 7, 2]</code>，按照冒泡排序的过程：</p>\n<ol>\n<li><p>第一轮冒泡：</p>\n<ul>\n<li>比较并交换<code>5</code>和<code>3</code>，得到<code>[3, 5, 8, 6, 7, 2]</code></li>\n<li>比较并交换<code>5</code>和<code>8</code>，得到<code>[3, 5, 8, 6, 7, 2]</code>（无需交换）</li>\n<li>…</li>\n<li>比较并交换<code>7</code>和<code>2</code>，得到<code>[3, 5, 6, 7, 2, 8]</code></li>\n</ul>\n</li>\n<li><p>第二轮冒泡：</p>\n<ul>\n<li>比较并交换<code>3</code>和<code>5</code>，得到<code>[3, 5, 6, 7, 2, 8]</code>（无需交换）</li>\n<li>…</li>\n<li>比较并交换<code>6</code>和<code>2</code>，得到<code>[3, 5, 6, 2, 7, 8]</code></li>\n</ul>\n</li>\n<li><p>继续这个过程，直到所有元素都已排序。</p>\n</li>\n</ol>\n<h3 id=\"三、冒泡排序代码实现\"><a href=\"#三、冒泡排序代码实现\" class=\"headerlink\" title=\"三、冒泡排序代码实现\"></a>三、冒泡排序代码实现</h3><p>以下是一个简单的冒泡排序实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bubble_sort</span>(<span class=\"params\">arr</span>):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 遍历所有数组元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"comment\"># 提前退出标志，表示已经有序</span></span><br><span class=\"line\">        swapped = <span class=\"literal\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 对每轮剩下的元素进行遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, n - i - <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"comment\"># 如果前一个元素比后一个元素大，则交换它们</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[j] &gt; arr[j + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                arr[j], arr[j + <span class=\"number\">1</span>] = arr[j + <span class=\"number\">1</span>], arr[j]</span><br><span class=\"line\">                swapped = <span class=\"literal\">True</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"comment\"># 如果本轮没有发生过交换，说明已经有序，提前退出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> swapped:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、冒泡排序的使用场景\"><a href=\"#四、冒泡排序的使用场景\" class=\"headerlink\" title=\"四、冒泡排序的使用场景\"></a>四、冒泡排序的使用场景</h3><p>尽管冒泡排序在处理大规模数据时效率较低，但它在特定场景下仍有实用价值：</p>\n<ul>\n<li>小规模或基本有序的数据集：当待排序的数据量较小，或者数据近乎有序时，冒泡排序可能具有相对较好的性能表现。</li>\n<li>简化版优化：例如，在每一轮冒泡过程中增加一个标记来判断是否发生交换，若没有发生则提前结束排序，这种改进后的冒泡排序对近乎有序的数组有较好效果。</li>\n</ul>\n","feature":false,"text":"本文主要介绍了Python 冒泡排序：原理、使用场景与实现方法...","permalink":"/post/Python-冒泡排序：原理、使用场景与实现方法","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":15,"path":"api/categories/编程.json"},{"name":"Python","slug":"编程/Python","count":12,"path":"api/categories/编程/Python.json"}],"tags":[{"name":"官方","slug":"官方","count":16,"path":"api/tags/官方.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">一、冒泡排序原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">二、冒泡排序步骤详解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">三、冒泡排序代码实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">四、冒泡排序的使用场景</span></a></li></ol>","author":{"name":"LaoShui","slug":"blog-author","avatar":"favicon.ico","link":"/","description":"<p>不忘初心，青春朝气永在</p><p>志在千秋，百年恰是少年</p>","socials":{"github":"https://github.com/laoshuikaixue","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"aliyun_developer":{"icon":"/svg/aliyun.svg","link":"https://developer.aliyun.com/profile/dtvevsc2d4xha"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Python 选择排序：原理、使用场景与实现方法","uid":"0490642c71381612a7160eef78d1d327","slug":"Python-选择排序：原理、使用场景与实现方法","date":"2024-02-09T08:16:22.000Z","updated":"2024-02-09T08:25:37.452Z","comments":true,"path":"api/articles/Python-选择排序：原理、使用场景与实现方法.json","keywords":null,"cover":[],"text":"本文主要介绍了Python 选择排序：原理、使用场景与实现方法...","permalink":"/post/Python-选择排序：原理、使用场景与实现方法","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":15,"path":"api/categories/编程.json"},{"name":"Python","slug":"编程/Python","count":12,"path":"api/categories/编程/Python.json"}],"tags":[{"name":"官方","slug":"官方","count":16,"path":"api/tags/官方.json"}],"author":{"name":"LaoShui","slug":"blog-author","avatar":"favicon.ico","link":"/","description":"<p>不忘初心，青春朝气永在</p><p>志在千秋，百年恰是少年</p>","socials":{"github":"https://github.com/laoshuikaixue","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"aliyun_developer":{"icon":"/svg/aliyun.svg","link":"https://developer.aliyun.com/profile/dtvevsc2d4xha"}}}},"feature":false},"next_post":{"title":"时间复杂度在编程中的应用与实例分析","uid":"21aab6d167e8b8f08f85d33c3f085939","slug":"时间复杂度在编程中的应用与实例分析","date":"2024-02-08T12:30:04.000Z","updated":"2024-02-09T08:20:18.984Z","comments":true,"path":"api/articles/时间复杂度在编程中的应用与实例分析.json","keywords":null,"cover":null,"text":"本文主要分享了时间复杂度在编程中的应用与实例分析...","permalink":"/post/时间复杂度在编程中的应用与实例分析","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":15,"path":"api/categories/编程.json"},{"name":"Python","slug":"编程/Python","count":12,"path":"api/categories/编程/Python.json"}],"tags":[{"name":"官方","slug":"官方","count":16,"path":"api/tags/官方.json"}],"author":{"name":"LaoShui","slug":"blog-author","avatar":"favicon.ico","link":"/","description":"<p>不忘初心，青春朝气永在</p><p>志在千秋，百年恰是少年</p>","socials":{"github":"https://github.com/laoshuikaixue","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"aliyun_developer":{"icon":"/svg/aliyun.svg","link":"https://developer.aliyun.com/profile/dtvevsc2d4xha"}}}},"feature":false}}