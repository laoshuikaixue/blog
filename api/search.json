[{"id":"e762971b5e5d5706d967112712c93106","title":"信息技术 · 必修一 · 第一章 数据与信息 知识点","content":"当我写下这篇文章时 我正式开始了对高中信息技术教材的学习 我会在空闲时间不断补充内容\n数据是对客观事物的符号表示，如图形符号、数字、字母等。其中，数字是最简单的一种数据。单纯的数据是没有意义的，经过解释，数据才变得有意义。人们在利用数据的同时，自身的行为也在产生数据。科学研究离不开数据。\n计算机科学中，数据是指所有能输入到计算机并被计算机程序处理的符号总称，其表现形式可以是文字、图形、图像、音频、视频等。\n信息的特征：载体依附性、时效性、共享性、可加工处理性、真伪性、价值性。\n信息与载体区分：信息是看不见摸不着的。文字、图像、声音、二进制代码等都是信息的载体，文字、图像里面所表达的意思才是信息。\n信息是不能独立存在的，它的表示、传播、存储必须依附于载体(载体依附性)，不存在没有载体的信息。如果存储信息的载体遭到破坏，那么其承载的信息就会消失。信息可以脱离它所反映的事物被存储、保留和传播(但不能脱离载体)。\n信息往往反映的是事物某一特定时间内的状态，它会随着时间的推移而变化。\n信息是可以共享的，同一种信息可以同时被不同的接收者获取，人们也可以重复利用信息。与物质、能源不同的是，信息不会因为被别人获取而发生损耗。\n信息的价值也是相对的，对于不同的人群、不同的时间，其价值可能有所不同。\n数据、信息与知识的关系 \n目前数据的获取方法以机器获取为主，传感器随时获取来自自然信源的数据，网络爬虫可在短时间内获取大量网络数据。 \n信息可用模拟信号或数字信号表达。模拟信号以连续变化的物理量存在，当字信号在取值上是离散的、不连续的信号。\n模拟信号与数字信号可以相互转换，其中将模拟信号转换为数字信号的过程称为数字化，通常需要经过采样、量化与编码三个步骤。每秒采样的样本数称为采样频率，单位为赫兹(Hz)。在采样过程中，提高采样频率可以减少失真并提升保真度。模拟信号经过采样后成为离散信号，随后通过量化将离散信号的连续取值近似为有限个离散值，并用数值表示。以声音数字化为例，声音信号通过麦克风转为电流信号，再经声卡上的模数转换器(ADC)将电流信号转为数字信号，经过采样、量化后进行编码并存储于计算机中。在重放时，数字信号通过数模转换器(DAC)还原为模拟信号，放大后送至扬声器发声。\n\n","slug":"信息技术-·-必修一-·-第一章-数据与信息-知识点","date":"2024-12-13T10:06:22.000Z","categories_index":"高中,必修一,数据与信息,编程,Python","tags_index":"教材学习","author_index":"LaoShui"},{"id":"c0cbd51e6cc6162b96e9aed7b5281420","title":"开源：升学E网通绕过会员以及点击检测（已失效）","content":"开源地址：https://github.com/laoshuikaixue/ewt360/\newt360前言\n\n\n\n\n\n\n\n\n请不要滥用此仓库中的内容ewt有时可能会做更新，程序不保证一定能用  \n目前实现的功能\n 绕过点击检测\n 绕过点击检测（无数据上报 慎用）\n\n使用说明\n绕过会员检测\n此功能用于观看视频出现此提示的绕过 你需要安装油猴脚本插件 安装方法请自行上网搜索\n随后添加这个脚本：https://greasyfork.org/zh-CN/scripts/500965-ewt360-permission-interceptor 即可绕过\n原理：\n\n拦截返回内容 修改这部分内容 对播放器进行欺骗\n\n绕过点击检测：首先 打开视频页面\n随后 打开浏览器的DevTools（按F12或右键 这里推荐使用EDGE以及谷歌浏览器）\n\n找到此JS 右键点击 点击替代内容（如果没有 请更换上述推荐浏览器并检查浏览器版本）\n在文件导航对话框中，选择本地计算机上的一个文件夹来存储要替换的资源文件，例如 C:\\Users\\myusername\\overrides，然后单击 选择文件夹 按钮\nDevTools 警告你必须具有对该文件夹的完全访问权限，并且不应泄露任何敏感信息\n单击 允许 按钮 随后在打开的页面中粘贴项目中txt文本内的内容（JS加密了 可能会无响应 可以修改后缀后直接替换掉这个文件）\n随后刷新一次页面 弹出\n\n即代表加载成功 随后关闭DevTools 即可播放视频\n注意：此操作会导致教师后台无点击通过率数据 谨慎使用注意：如果你需要加载补丁 你需要每次打开页面的时候都打开DevTools进行一次刷新操作\n\n推荐的同类项目\n刷课+自动完成选择题的工具箱 刷课+自动完成选择题的工具箱（油猴脚本）\n刷课+自动完成选择题的工具箱 上述脚本开源地址  \newt360 Python实现刷e网通假期课程进度（停止维护）\n\n后言此仓库内容仅供学习参考使用 学习后请立即删除 因使用者产生的个人问题与本仓库开发者无关\n禁止滥用本仓库的内容 若进行二开请严格遵守license 严禁各类商业行为\n若发现失效等情况 请在仓库的issues中或下方评论区（匿名邮箱不予回复 回了你也收不到）提出 并欢迎PR\n","slug":"开源：升学E网通绕过会员以及点击检测","date":"2024-07-18T07:37:54.000Z","categories_index":"开源,编程","tags_index":"官方","author_index":"LaoShui"},{"id":"d06e89d326c3b959da197d0b11709006","title":"探索2FA双因素认证与TOTP时间同步一次性密码","content":"2FA (Two-Factor Authentication) 与 TOTP (Time-Based One-Time Password)引言在当今数字化时代，信息安全的重要性日益凸显，传统的单一密码登录方式已经无法满足高效且安全的身份验证需求。因此，双因素认证（2FA, Two-Factor Authentication）应运而生，作为一项关键的安全措施，它要求用户提供两个独立的证明身份的方式，显著提高了账户安全性。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是2FA中的一个重要实现方案。\n什么是2FA（双因素认证）双因素认证（2FA）是一种多层次的身份验证机制，旨在确保只有授权用户能够访问受保护的资源。根据NIST（美国国家标准与技术研究院）的定义，它结合了以下至少两种认证因素：\n\n知识因素：只有用户知道的信息，如密码、PIN码或者安全问题的答案；\n所有权因素：用户拥有的物理设备或虚拟凭证，如智能手机、USB令牌、短信验证码或生物特征；\n内在因素：用户固有的生物特征，如指纹、面部识别或虹膜扫描。\n\nTOTP（时间同步一次性密码）原理TOTP 是2FA的一个具体实现，它基于时间的一次性密码算法。在这个机制下，用户和服务器双方共同持有预先共享的秘密密钥。每隔一段固定的时间间隔（通常为30秒），双方都会根据当前时间戳和此密钥通过HMAC（Hash-based Message Authentication Code）算法计算出一个唯一的、短暂有效的动态密码。\n工作流程\n密钥生成与存储：\n\n用户在启用TOTP时，会生成一个基于特定算法的密钥，并将其保存在服务器端和用户端（通常是手机上的认证APP）。\n\n\n时间同步：\n\nTOTP算法依赖于时间同步，客户端和服务端各自基于当前时间戳计算哈希值。\n\n\n密码生成：\n\n使用HMAC函数，将当前时间戳与共享密钥相结合生成一个哈希值。\n从哈希值中抽取一定长度的数值作为一次性密码。\n\n\n验证过程：\n\n当用户尝试登录时，在认证APP上获取并输入当前的有效TOTP密码。\n服务器同样根据当前时间戳计算TOTP密码，并与用户提交的密码进行比对，如果匹配，则验证成功。\n\n\n\n总归来说，使用 TOTP 来进行 2FA 的第一步就是通过 QRCode Server 让跟 Client(App) 约定好一个秘密，之后就都用那个秘密跟接下来的时间来进行 Hash 。我们就按这个流程来评估每个步骤的安全性。\n结论TOTP作为双因素认证的重要组成部分，不仅强化了传统密码体系，而且在实施过程中具有简单易用、成本低廉的特点。随着越来越多的在线服务提供商采用2FA和TOTP，这种基于时间的一次性密码技术已经成为提升账户安全性的主流手段之一。无论是企业级应用还是个人用户，启用TOTP能够有效抵御诸如网络钓鱼、密码猜测等常见安全威胁，保障数字资产和个人信息安全。\n","slug":"探索2FA双因素认证与TOTP时间同步一次性密码","date":"2024-03-02T04:06:33.000Z","categories_index":"编程,安全","tags_index":"官方","author_index":"LaoShui"},{"id":"70c15220323e313ec6083d38a84c2668","title":"Python 快速排序：原理、使用场景与实现方法","content":"引言快速排序（Quick Sort）是由英国计算机科学家托尼·霍尔于1960年提出的一种高效的排序算法。其主要特点在于采用了分治策略，通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n一、快速排序原理\n选择基准元素：首先在待排序数组中选取一个基准元素（通常选择第一个或最后一个元素，也可以采用随机选择的方式以提高平均性能）。\n\n分区操作：重新排列数组，使得基准元素之前的所有元素都不大于它，之后的所有元素都不小于它。这个过程称为分区操作，可以通过两个指针从两端向中间移动，并交换不满足条件的元素位置来完成。\n\n递归排序：然后分别对基准元素左侧和右侧的子数组进行快速排序，直至所有子数组只有一个元素或者为空。\n\n\n二、快速排序步骤详解假设有一个无序数组[5, 3, 8, 6, 7, 2]，按照快速排序的过程：\n\n选择基准元素：我们选择第一个元素5作为基准。\n分区操作：\n从右向左找到第一个小于基准的元素2，从左向右找到第一个大于基准的元素8，交换它们的位置，得到[2, 3, 5, 6, 7, 8]\n继续左右扫描，交换5和3，得到最终分区结果[2, 3, 5, 6, 7, 8]，此时基准元素位于正确位置\n\n\n递归排序：\n对[2, 3]子数组进行快速排序\n对[6, 7, 8]子数组进行快速排序\n\n\n\n三、快速排序代码实现以下是一个简单的快速排序实现：\n1234567891011121314def quick_sort(arr):    if len(arr) &lt;= 1:        return arr        pivot = arr[len(arr) // 2]    left = [x for x in arr if x &lt; pivot]    middle = [x for x in arr if x == pivot]    right = [x for x in arr if x &gt; pivot]        return quick_sort(left) + middle + quick_sort(right)# 示例调用unsorted_array = [5, 3, 8, 6, 7, 2]sorted_array = quick_sort(unsorted_array)\n\n四、快速排序的使用场景\n大规模数据排序：由于快速排序的平均时间复杂度为O(n log n)，对于大规模数据排序任务，快速排序具有较高的效率，尤其是在内部实现优化后，如“三数取中法”选择基准等技巧，能进一步提升性能。\n教育示例：快速排序展示了分治策略在解决问题上的强大威力，是学习、竞赛中广泛使用的经典实例。\n实际应用：在很多编程语言的标准库中，快速排序被用于实现数组和列表的排序功能，例如C++ STL中的std::sort函数就采用了快速排序及其改进版。\n\n需要注意的是，在最坏情况下，当输入数据已经完全有序或逆序时，快速排序的时间复杂度会退化到O(n²)，但这种情况在实际应用中相对较少见。为了规避这一问题，可以采用随机化选择基准元素的方法，使算法在概率意义下有较好的表现。\n","slug":"Python-快速排序：原理、使用场景与实现方法","date":"2024-02-09T08:31:40.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"0425545bbf78488183c9b7bbe87131db","title":"Python 插入排序：原理、使用场景与实现方法","content":"引言插入排序（Insertion Sort）是一种简单直观且易于理解的排序算法，其工作原理类似于我们手动整理扑克牌的过程。通过构建一个有序序列，每次从未排序部分中取出一个元素并将其插入到已排序序列的正确位置，直到整个序列有序。尽管在处理大规模数据时效率较低，但对于小规模数据或部分有序的数据集，插入排序表现出了较好的性能。\n\n一、插入排序原理\n构建初始有序序列：首先将数组的第一个元素视为已排序序列。\n逐个插入：从第二个元素开始，依次与已排序序列中的元素进行比较，找到合适的插入位置，并将其插入。\n重复上述过程：继续对剩余未排序元素执行相同的操作，直至所有元素都已排序到位。\n\n二、插入排序步骤详解假设有一个无序数组[5, 3, 8, 6, 7, 2]，按照插入排序的过程：\n\n第一轮：\n\n数组的第一个元素默认为已排序部分，即[5]\n将第二个元素3与5进行比较，发现3小于5，所以将3插入到5之前，得到[3, 5]\n\n\n第二轮：\n\n已排序部分为[3, 5]\n将第三个元素8与已排序部分的元素依次比较，无需移动，得到[3, 5, 8]\n\n\n继续这个过程，直到所有元素都已排序。\n\n\n三、插入排序代码实现以下是一个简单的插入排序实现：\n12345678910111213141516def insertion_sort(arr):    n = len(arr)        # 遍历数组中的每个元素    for i in range(1, n):        current = arr[i]        j = i - 1                # 将当前元素与其左侧的已排序元素进行比较和交换        while j &gt;= 0 and arr[j] &gt; current:            arr[j + 1] = arr[j]            j -= 1                    arr[j + 1] = current            return arr\n\n四、插入排序的使用场景\n小规模数据集：对于数据量较小的情况，插入排序可以快速完成排序任务，尤其是当数据近乎有序时，其时间复杂度接近O(n)。\n在部分场景下的优化：例如，当待排序数据基本有序时，插入排序能有效减少元素之间的比较次数，从而提高排序效率。\n\n插入排序的时间复杂度达到O(n²)，因此插入排序也并非首选方案。\n","slug":"Python-插入排序：原理、使用场景与实现方法","date":"2024-02-09T08:27:12.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"0490642c71381612a7160eef78d1d327","title":"Python 选择排序：原理、使用场景与实现方法","content":"引言选择排序（Selection Sort）是一种简单直观的排序算法，其主要思想是通过不断遍历待排序序列，并在每次遍历时找出剩余未排序部分中的最小（或最大）元素，将其放到已排序序列的末尾。虽然选择排序的时间复杂度并不优秀，但它简洁易懂的逻辑使其成为初学者理解排序算法的理想起点。\n\n一、选择排序原理选择排序的基本步骤如下：\n\n寻找最小值：首先从待排序的数组中选出最小（或最大）的元素。\n交换位置：将找到的最小元素与数组的第一个未排序元素交换位置，此时第一个元素为已排序区间的最后一个元素。\n重复上述过程：接着在剩余的未排序序列中重复寻找最小元素并交换的过程，直至整个序列有序。\n\n二、选择排序步骤详解假设有一个无序数组[5, 3, 8, 6, 7, 2]，按照选择排序的过程：\n\n第一轮：\n\n在所有未排序元素中找到最小值2，并与数组的第一个元素交换位置，得到[2, 3, 8, 6, 7, 5]\n\n\n第二轮：\n\n在剩下的未排序元素[3, 8, 6, 7, 5]中找到最小值3，与当前未排序区间的第一个元素交换位置，得到[2, 3, 8, 6, 7, 5]（这里无需交换，因为3已经位于正确位置）\n\n\n继续这个过程，直到所有元素都已排序。\n\n\n三、选择排序代码实现以下是一个简单的选择排序实现：\n123456789101112131415def selection_sort(arr):    n = len(arr)        # 遍历所有数组元素    for i in range(n):        # 找到剩余未排序部分中的最小元素索引        min_index = i        for j in range(i + 1, n):            if arr[j] &lt; arr[min_index]:                min_index = j                        # 将找到的最小元素与未排序区间的第一个元素交换        arr[i], arr[min_index] = arr[min_index], arr[i]            return arr\n\n四、选择排序的使用场景尽管选择排序通常不是最优选择，但在特定场景下仍有一定的实用价值：\n\n稳定性需求：选择排序是一种稳定的排序算法，即相等的元素在排序后相对顺序保持不变，这在处理具有特殊稳定性需求的问题时可能有优势。\n数据量较小且对效率要求不高的场合：对于小规模数据集或者对运行速度要求不苛刻的应用场景，选择排序可以作为一个简单的解决方案。\n\n然而，选择排序的时间复杂度始终为O(n²)，其性能远不如快速排序、归并排序和堆排序等高效算法。因此，在实际开发、竞赛中，尤其是在对效率有较高要求的情况下，选择排序并非首选方案。\n","slug":"Python-选择排序：原理、使用场景与实现方法","date":"2024-02-09T08:16:22.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"5a1ed4bfdc47ff55e285206610294889","title":"Python 冒泡排序：原理、使用场景与实现方法","content":"引言冒泡排序（Bubble Sort）是一种简单直观的排序算法，因其运作机制类似于水中的气泡不断向上浮起而得名。虽然在实际应用中，冒泡排序通常不是最优选择，但其原理清晰易懂，常被用作学习和理解排序算法的基础，对于初学者有着重要的教育价值。\n\n一、冒泡排序原理冒泡排序的基本思想是通过不断交换相邻两个元素的位置，使较大的元素逐渐“浮”到序列的末尾，每一轮循环都会将当前未排序序列中的最大（或最小）元素“冒泡”至正确位置。\n\n比较并交换过程：从数组的第一个元素开始，每次遍历都将相邻的元素两两进行比较，如果前一个元素大于后一个元素，则交换它们的位置。\n重复上述过程：每完成一次遍历（即一趟冒泡），最后一个元素将是当前未排序部分的最大值。因此，需要重复此过程n-1次，以确保整个数组完全有序。\n\n二、冒泡排序步骤详解假设有一个无序数组[5, 3, 8, 6, 7, 2]，按照冒泡排序的过程：\n\n第一轮冒泡：\n\n比较并交换5和3，得到[3, 5, 8, 6, 7, 2]\n比较并交换5和8，得到[3, 5, 8, 6, 7, 2]（无需交换）\n…\n比较并交换7和2，得到[3, 5, 6, 7, 2, 8]\n\n\n第二轮冒泡：\n\n比较并交换3和5，得到[3, 5, 6, 7, 2, 8]（无需交换）\n…\n比较并交换6和2，得到[3, 5, 6, 2, 7, 8]\n\n\n继续这个过程，直到所有元素都已排序。\n\n\n三、冒泡排序代码实现以下是一个简单的冒泡排序实现：\n1234567891011121314151617181920def bubble_sort(arr):    n = len(arr)        # 遍历所有数组元素    for i in range(n):        # 提前退出标志，表示已经有序        swapped = False                # 对每轮剩下的元素进行遍历        for j in range(0, n - i - 1):            # 如果前一个元素比后一个元素大，则交换它们            if arr[j] &gt; arr[j + 1]:                arr[j], arr[j + 1] = arr[j + 1], arr[j]                swapped = True                        # 如果本轮没有发生过交换，说明已经有序，提前退出        if not swapped:            break                return arr\n\n四、冒泡排序的使用场景尽管冒泡排序在处理大规模数据时效率较低，但它在特定场景下仍有实用价值：\n\n小规模或基本有序的数据集：当待排序的数据量较小，或者数据近乎有序时，冒泡排序可能具有相对较好的性能表现。\n简化版优化：例如，在每一轮冒泡过程中增加一个标记来判断是否发生交换，若没有发生则提前结束排序，这种改进后的冒泡排序对近乎有序的数组有较好效果。\n\n","slug":"Python-冒泡排序：原理、使用场景与实现方法","date":"2024-02-09T08:11:13.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"21aab6d167e8b8f08f85d33c3f085939","title":"时间复杂度在编程中的应用与实例分析","content":"引言时间复杂度是对算法运行时间的理论分析工具，它揭示了随着输入数据规模n的增长，算法执行所需时间的变化趋势。本文将详细探讨四种常见的时间复杂度类型：常数阶O(1)、线性阶O(n)、对数阶O(log n)以及平方阶O(n^2)，并结合代码实例进行深入解析。\n一、常数阶时间复杂度 O(1)定义：常数阶时间复杂度表示无论输入数据规模如何变化，算法运行所需时间基本保持不变。\n实例分析：\n12def constant_time_operation(data):    return data[0]  # 不论data列表长度为多少，获取第一个元素的操作都是固定时间的\n在这个例子中，不论data列表有多长，获取第一个元素的时间是恒定的，因此该函数的时间复杂度为O(1)。\n二、线性阶时间复杂度 O(n)定义：线性阶时间复杂度表明算法的运行时间与输入数据规模成正比关系，数据规模每增加一个单位，运行时间也会相应地增加一个基本单位。\n实例分析：\n1234def linear_time_operation(data):    for item in data:        # 对data中的每个元素执行某项操作        pass\n上述代码遍历了一个列表或链表的所有元素，对于长度为n的数据结构，需要执行n次操作，所以其时间复杂度为O(n)。\n三、对数阶时间复杂度 O(log n)定义：对数阶时间复杂度意味着当数据规模翻倍时，所需时间仅增长一个单位。这种效率在处理大规模数据时表现优秀。\n实例分析：以二分查找为例\n12345678910111213141516def binary_search(data, target):    low, high = 0, len(data) - 1        while low &lt;= high:        mid = (low + high) // 2        if data[mid] == target:            return mid        elif data[mid] &lt; target:            low = mid + 1        else:            high = mid - 1                return -1  # 如果未找到目标值则返回-1# 在排序后的数组中查找目标值binary_search(sorted_data, target)\n在二分查找中，每次比较都将搜索范围缩小一半，因此在最坏情况下，查找长度为n的已排序数组中的元素所需次数最多为log2(n)，故此函数的时间复杂度为O(log n)。\n四、平方阶时间复杂度 O(n^2)定义：平方阶时间复杂度意味着算法的运行时间与输入数据规模的平方成正比，当数据规模增大时，计算时间会急剧增加。\n实例分析：以冒泡排序为例\n123456789def bubble_sort(data):    n = len(data)        for i in range(n):        for j in range(0, n - i - 1):            if data[j] &gt; data[j + 1]:                data[j], data[j + 1] = data[j + 1], data[j]                    return data\n冒泡排序通过两层循环完成排序，外层循环次数为n，内层循环次数随外层循环递减，但最大仍为n次。因此，在最坏的情况下，总共进行了n * (n-1)&#x2F;2次比较和交换，时间复杂度为O(n^2)。\n总结来说，理解和掌握不同时间复杂度的概念及其对应的典型算法，有助于我们在编程实践中选择最优解法，合理的时间复杂度分析能有效提升程序性能和解题效率。\n","slug":"时间复杂度在编程中的应用与实例分析","date":"2024-02-08T12:30:04.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"389b18851d712cc1db6a774e37294354","title":"竞赛编程中分析时间复杂度与空间复杂度的重要性","content":"引言在竞赛编程领域，高效且准确的算法是决胜的关键。而衡量一个算法优劣的重要指标，便是其时间和空间复杂度。本文将深入探讨在竞赛编程中如何理解和分析时间复杂度与空间复杂度，以及它们对于优化代码性能、提升解题效率的重要性。\n一、时间复杂度1. 定义时间复杂度是对算法运行时间的量化度量，它描述的是问题规模n增大时，算法执行时间的增长速度。通常用大O符号（Big O notation）表示，例如：O(1)，O(n)，O(log n)，O(n^2)等。\n2. 分析方法\n常数阶时间复杂度 O(1)：无论输入数据规模如何，算法运行的时间基本保持不变。\n线性阶时间复杂度 O(n)：算法运行时间与输入数据规模成正比，如遍历数组或链表。\n对数阶时间复杂度 O(log n)：二分查找、堆排序等算法在处理大量数据时表现出优秀的效率。\n平方阶时间复杂度 O(n^2)：如冒泡排序、选择排序等，当数据规模增大时，计算时间急剧增加。\n\n在竞赛中，我们通常会选择时间复杂度低的算法以保证程序能在规定时间内完成求解。\n二、空间复杂度1. 定义空间复杂度是指算法在运行过程中临时占用存储空间大小的增长趋势，同样使用大O符号表示。\n2. 分析方法\n常数阶空间复杂度 O(1)：算法所需额外空间不随输入数据规模增大而增大，比如大部分数学运算函数。\n线性阶空间复杂度 O(n)：算法所需空间与输入数据规模成正比，如动态规划中的数组存储状态，或者深度优先搜索过程中的递归栈。\n对数阶、指数阶等其他复杂度：根据具体情况，可能需要考虑更复杂的空间消耗模型。\n\n在某些限制内存使用的竞赛题目中，降低空间复杂度尤为重要，避免因内存溢出而导致程序崩溃。\n三、实战应用在实际竞赛编程中，理解并熟练运用时间复杂度和空间复杂度分析，能够帮助我们：\n\n快速识别并排除明显效率较低的解题方案；\n在多种解法中选取最优策略，特别是在大规模数据场景下；\n设计更为精巧的算法，提高代码运行效率；\n预估程序性能，合理安排代码结构，防止超时或内存溢出。\n\n接下来的文章会详细介绍这些算法的优劣和使用方法\n","slug":"竞赛编程中分析时间复杂度与空间复杂度的重要性","date":"2024-02-08T10:41:34.000Z","categories_index":"编程","tags_index":"官方","author_index":"LaoShui"},{"id":"1ce36757e3e88b272b7c9f6027d9ece0","title":"基于函数计算3.0 Stable Diffusion Serverless API 的AI艺术字头像生成应用搭建与实践的报告","content":"随着AIGC技术的热度持续升高，AI绘画以其独特创新的艺术表现力吸引了广泛的关注，我通过利用阿里云函数计算团队开发的基于Stable Diffusion Serverless API解决方案，搭建了一套能够满足多场景需求的高性能、易部署和可扩展的AI艺术字头像生成平台。\n利用Stable Diffusion Serverless API强大的并发能力，多个请求可以并行处理，显著提高出图效率。用户还可以通过高级设置调整文字内容、字体、颜色、位置大小等细节参数，以及Stable Diffusion模型本身的渲染选项如迭代步数、提示词、反向提示词等，快速生成具有艺术特色的AI文字头像，尤其适合在春节期间进行分享展示。\n实验过程中 使用了如下阿里云服务：\n函数计算 FC（Function Compute）对象存储 OSS表格存储 Tablestore\n实验后，真实感受到了阿里云函数计算FC 3.0的全托管、事件驱动特性使整个应用轻量灵活，易于集成和扩展。未来，随着AIGC技术不断进步，此类Serverless解决方案将为更多开发者提供便捷的工具链和服务环境，进一步推动AI绘画技术在各行业中的创新应用和商业化落地。\n\n\n\n\n\n","slug":"基于函数计算3-0-Stable-Diffusion-Serverless-API-的AI艺术字头像生成应用搭建与实践的报告","date":"2024-02-08T10:10:35.000Z","categories_index":"编程,fc AIGC,Serverless,人工智能,函数计算","tags_index":"官方","author_index":"LaoShui"},{"id":"d474c339b16bd4b2fa6459002b26491b","title":"Python OJ题典型算法：字符型数据与ASCII码详解","content":"介绍本文将介绍字符型数据与ASCII码的相关知识点。\n解析在计算机中，字符型数据与ASCII码密切相关。ASCII（American Standard Code for Information Interchange）是一种用于表示文本字符的编码方式。\n解题思路要理解字符型数据与ASCII码之间的关系，我们首先需要了解ASCII码的基本概念和原理。\nASCII码使用7位二进制数（即128个不同的值）来表示所有的可打印字符、控制字符以及一些特殊字符。每个字符都有一个对应的唯一的ASCII码。\n在字符串中，每个字符都可以用一个ASCII码来表示。例如，字符’A’对应的ASCII码是65，字符’a’对应的ASCII码是97。\n代码实现下面是一个示例代码，演示了如何将字符转换为对应的ASCII码：\n12345678# 输入一个字符char = input(&quot;请输入一个字符：&quot;)# 使用ord()函数获取字符的ASCII码ascii_code = ord(char)# 输出ASCII码print(&quot;字符&quot;, char, &quot;的ASCII码是：&quot;, ascii_code)\n\n测试示例假设输入的字符是：’A’\n输出：\n1字符 A 的ASCII码是： 65\n\n解题技巧\n要记住ASCII码中常见字符的对应关系，可以通过查看ASCII码表或使用编程语言提供的内置函数来获取。\n可以使用ord()函数将字符转换为对应的ASCII码，使用chr()函数将ASCII码转换为对应的字符。\n在处理字符串时，需要注意字符编码的问题，尤其是当涉及到不同编码方式（如Unicode）时。\n\n总结本文介绍了字符型数据与ASCII码的关系，以及如何将字符转换为对应的ASCII码。通过理解和掌握这些知识点，我们可以在编程中更方便地处理字符型数据，并进行相关的操作。\n","slug":"Python-OJ题典型算法：字符型数据与ASCII码详解","date":"2024-01-20T14:47:10.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"c7d0ccfa3f344c02b0cc5d43076d420e","title":"Python OJ题：快速求出现次数最多的数字","content":"例题问题描述景区在售票时，从游客身份证中提取了年龄信息。现在，景区管理员想知道，按年龄统计，游客数量最多的是什么年龄？\n输入只有一行，n 个游客年龄数据，数据为整数，两个数据之间有一个空格\n输出第一行：输出最多游客数量的年龄，相同数量的，优先输出年龄大的\n第二行：输出最多游客的数量\n样例135 40 80 40 40 40 35 40 15 20\n\n12405\n\n\n分析要解决这道题，我们只需要创建一个列表，记录游客的年龄信息，然后找到列表中元素出现的频次，并找出出现次数最多的元素及其对应的出现次数\n那么我们可以通过Python collections 模块中的 Counter 类来快速找到列表中出现最多的数字\nCounter 是一个字典子类，用于计数可哈希对象（如本题中列表中的元素）的数量\n实现我们首先创建一个 Counter 对象 c，通过传入列表 lst 进行初始化。在这个过程中，Counter 对 lst 中的所有元素进行计数，结果是一个字典，其中键是列表中的元素，值是它们在列表中出现的次数\n1c = Counter(lst)\n\n然后使用 Counter 的 most_common() 方法获取出现次数最多的元素。most_common() 方法返回一个列表，其中包含元组，每个元组包含一个元素及其出现次数，按出现次数从高到低排序\n12c.most_common(1)[0][0]c.most_common(1)[0][1]\n\n\nc.most_common(1) 表示我们只需要出现次数最多的那一个元素及其出现次数，因此传入参数 1\n\n[0][0] 和 [0][1] 分别用于获取这个元组的第一个和第二个元素，也就是出现次数最多的元素及其对应的出现次数\n\n\n再将出现次数最多的元素赋值给变量 a，出现次数赋值给变量 b\n12a = c.most_common(1)[0][0]b = c.most_common(1)[0][1]\n\n最后，分别打印出出现次数最多的元素 a 和其对应的出现次数 b\n12print(a)print(b)\n\n但要注意的是，本题中要求相同数量的，优先输出年龄大的。而使用这种方法会优先输出年龄小的，所以我们需要做一些改变\n代码示例1234567891011121314from collections import Counterlst = list(map(int, input().split()))c = Counter(lst)max_count = max(c.values())max_ages = [age for age, count in c.items() if count == max_count]max_ages.sort(reverse=True)a = max_ages[0]b = max_countprint(a)print(b)","slug":"Python-OJ题：快速求出现次数最多的数字","date":"2024-01-11T14:45:34.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"53f16d3eee15b742a4cfb37b3a93125a","title":"Python OJ题经典字符串操作——大小写转换","content":"题目介绍给定一个字符串，要求将其中的大写字母转换为小写字母，同时将小写字母转换为大写字母，并返回转换后的字符串。\n题目解析我们需要实现一个函数，接受一个字符串作为输入，然后对字符串进行大小写转换并返回结果。可以使用内置函数str.swapcase()来实现大小写转换。\n解题思路\n定义一个函数，接受一个字符串作为参数。\n使用str.swapcase()方法对字符串进行大小写转换。\n返回转换后的字符串。\n\n代码实现12345def swap_case(string):    return string.swapcase()# 测试示例print(swap_case(&#x27;Hello, World!&#x27;))  # 输出：hELLO, wORLD!\n\n解题技巧\nPython中可以使用str.swapcase()方法来进行大小写转换，非常简便。\n大小写转换是很常见的字符串处理操作，能够帮助我们快速进行字符串的格式调整。\n\n总结通过本题，我们了解到了如何使用Python中的str.swapcase()方法来对字符串进行大小写转换。这个方法非常方便，在实际开发中可以用于各种字符串处理场景。熟练掌握字符串操作可以提高编程效率，是每个开发者必备的基础技能。\n","slug":"Python-OJ题经典字符串操作——大小写转换","date":"2023-08-01T08:52:23.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"5bde76cf410436941caa57581e05a9eb","title":"信息学奥赛 如何在整数数组中寻找两数之和等于给定目标值","content":"题目介绍在一个整数数组中，找出两个数之和等于给定目标值。假设每个输入只有一个解，并且同一个元素不能使用两次。\n题目解析给定一个整数数组 nums 和一个目标值 target，要求返回数组中满足两数之和等于目标值的两个数的索引。\n解题思路一种简单的解法是使用两层循环遍历数组中的每对元素，判断它们的和是否等于目标值。这种解法的时间复杂度为 O(n²)。\n更高效的解法是利用哈希表。我们可以遍历一次数组，将每个元素与其索引存储在哈希表中。然后再遍历一次数组，对于每个元素，计算目标值与当前元素的差值，并检查这个差值是否在哈希表中。如果存在，则找到了两个数的索引。这种解法的时间复杂度为 O(n)。\n代码实现1234567def twoSum(nums, target):    hashmap = &#123;&#125;    for i, num in enumerate(nums):        complement = target - num        if complement in hashmap:            return [hashmap[complement], i]        hashmap[num] = i\n\n解题技巧\n使用哈希表可以将寻找目标值的时间复杂度从 O(n) 降低到 O(1)。\n\n总结本文介绍了在一个整数数组中寻找两个数之和等于给定目标值的方法。通过使用哈希表，我们可以以更高效的方式解决这个问题。当然，在解题时需注意题目中的约束条件，例如每个输入只有一个解，同一个元素不能使用两次等。\n","slug":"信息学奥赛-如何在整数数组中寻找两数之和等于给定目标值","date":"2023-08-01T08:49:28.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"58c7dcee11106804fdb10b6d10e556f9","title":"Python OJ题典例：判断回文串","content":"题目介绍这是一个经典的字符串处理问题。给定一个字符串，要求判断它是否是回文串。回文串是指正序和倒序读都一样的字符串。\n题目解析对于给定的字符串，我们需要判断它是否是回文串。回文串具有以下特点：\n\n字符串长度为奇数时，中间的字符可以忽略，对称位置的字符相同。\n字符串长度为偶数时，对称位置的字符相同。\n\n解题思路为了判断一个字符串是否是回文串，我们可以采用以下步骤：\n\n假设字符串的长度为n。\n使用两个指针，分别指向字符串的首位和末位。\n比较两个指针指向的字符，如果相同，则继续向中间移动，直到两个指针相遇或者不相同。\n如果两个指针相遇，则说明该字符串是回文串；如果两个指针不相同，则说明该字符串不是回文串。\n\n代码实现123456789101112131415def is_palindrome(s):    left = 0    right = len(s) - 1        while left &lt; right:        if s[left] != s[right]:            return False        left += 1        right -= 1        return True    # 测试示例print(is_palindrome(&quot;level&quot;))  # 输出：Trueprint(is_palindrome(&quot;hello&quot;))  # 输出：False\n\n解题技巧\n在比较字符时，可以使用ASCII码进行比较，提高比较效率。\n可以将字符串转换成小写或大写字母后再进行比较，忽略大小写的差异。\n\n总结通过使用双指针的方法，我们可以高效地判断一个字符串是否是回文串。这种解法的时间复杂度为O(n)，其中n是字符串的长度。在实际应用中，我们可以利用该方法来解决一些涉及字符串处理的问题。 \n","slug":"Python-OJ题典例：判断回文串","date":"2023-08-01T08:47:00.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"a6ce43f330920306cdee8f98cd33fefd","title":"解密经典数学问题：跳马问题的DFS解法","content":"题目介绍跳马问题是一个经典的数学问题，它涉及到一个马在棋盘上跳跃的路径规划。马在国际象棋中的走法是以字母表示，例如“D3”表示从位置D3跳到下一个位置。在跳马问题中，我们需要找到一条路径，使得马能够经过棋盘上的每个位置恰好一次。\n题目解析给定一个n x m的棋盘，我们需要找到一条路径，使得马能够从任意起始位置开始，经过每个位置恰好一次，并且最后回到起始位置。这是一个非常有趣且具挑战性的问题，它可以通过深度优先搜索（DFS）来解决。\n解题思路\n首先，我们定义一个n x m的棋盘，并用一个二维数组表示每个位置的访问情况。\n然后，我们选择一个起始位置作为DFS的起点，并将该位置标记为已访问。\n在DFS的过程中，我们检查当前位置的周围未访问的位置，并计算它们的可行度。\n可行度是指该位置周围未访问的位置的数量。我们可以根据可行度对周围位置进行排序，以便选择下一步要跳到的位置。\n选择下一步要跳到的位置后，我们进行递归调用DFS，并将该位置标记为已访问。\n重复上述步骤，直到所有的位置都被访问过。\n最后，我们判断最后一个位置是否能够与起始位置相连，如果可以，则说明找到了一条路径。\n\n代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def valid_moves(pos, board, visited):    # 计算当前位置的可行度    count = 0    for move in [(2, -1), (2, 1), (-2, -1), (-2, 1), (-1, 2), (-1, -2), (1, 2), (1, -2)]:        x = pos[0] + move[0]        y = pos[1] + move[1]        if 0 &lt;= x &lt; len(board) and 0 &lt;= y &lt; len(board[0]) and not visited[x][y]:            count += 1    return countdef dfs(pos, moves, board, visited):    visited[pos[0]][pos[1]] = True    moves.append(pos)        if len(moves) == len(board) * len(board[0]):        return True        next_moves = []    for move in [(2, -1), (2, 1), (-2, -1), (-2, 1), (-1, 2), (-1, -2), (1, 2), (1, -2)]:        x = pos[0] + move[0]        y = pos[1] + move[1]        if 0 &lt;= x &lt; len(board) and 0 &lt;= y &lt; len(board[0]) and not visited[x][y]:            next_moves.append((x, y))        next_moves.sort(key=lambda move: valid_moves(move, board, visited))        for move in next_moves:        if dfs(move, moves, board, visited):            return True        moves.pop()    visited[pos[0]][pos[1]] = False    return Falsedef solve(board):    n = len(board)    m = len(board[0])    visited = [[False for _ in range(m)] for _ in range(n)]        for i in range(n):        for j in range(m):            moves = []            if dfs((i, j), moves, board, visited):                return moves        return []# 测试示例board = [[0, 0, 0, 0],          [0, 0, 0, 0],         [0, 0, 0, 0]]moves = solve(board)for move in moves:    print(move)\n\n解题技巧\n在DFS的过程中，我们可以根据马在当前位置的可行度来选择下一步要跳到的位置，这样可以提高搜索效率。\n可以使用剪枝技巧来减少不必要的搜索。例如，如果一个位置已经被访问过，我们可以直接跳过该位置，不再进行递归调用。\n\n总结跳马问题是一个有趣且具挑战性的问题，通过深度优先搜索算法可以解决。本文介绍了题目的背景和解析，给出了一种基于DFS的解题思路，并提供了相应的代码实现。通过合理选择下一步要跳到的位置和使用剪枝技巧，我们可以高效地找到一条满足条件的路径。\n","slug":"解密经典数学问题：跳马问题的DFS解法","date":"2023-08-01T08:42:48.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"32b2866d3e9af05b26a9546f73f441fc","title":"信息学奥赛 试除法：高效筛选素数的算法","content":"题目介绍素数是指只能被1和自身整除的正整数，例如2、3、5、7等。现在给定一个范围内的整数序列，你需要编写一个算法来筛选出其中的素数。\n题目解析题目要求我们从给定的整数序列中筛选出素数。我们需要设计一个算法来判断一个数是否为素数，并将素数添加到结果集合中。\n解题思路为了判断一个数是否为素数，我们可以使用试除法。对于一个待判断的数x，我们从2开始，一直试除到sqrt(x)为止。如果在这个过程中发现x可被某个数整除，则x不是素数；否则x是素数。\n具体的算法如下：\n\n定义一个空集合result，用于存储筛选出的素数。\n对于每个待判断的数x，从2开始循环到sqrt(x)，判断x是否能够被这些数整除。\n如果x不能被任何数整除，则将x添加到result集合中。\n循环结束后，返回result作为结果。\n\n代码实现12345678910111213141516171819202122import mathdef sieve_of_eratosthenes(n):    primes = []    is_prime = [True] * (n + 1)    is_prime[0] = is_prime[1] = False    for i in range(2, int(math.sqrt(n)) + 1):        if is_prime[i]:            for j in range(i * i, n + 1, i):                is_prime[j] = False    for i in range(2, n + 1):        if is_prime[i]:            primes.append(i)    return primes# 测试示例n = 100result = sieve_of_eratosthenes(n)print(result)\n\n解题技巧\n在试除法中，我们只需要循环到sqrt(x)即可，因为如果存在大于sqrt(x)的因子，那么一定存在小于sqrt(x)的因子。\n使用一个布尔数组is_prime来记录每个数是否为素数，初始化为True，然后依次将非素数位置的值置为False，这样可以避免重复判断和减少计算量。\n\n总结本文介绍了如何使用试除法筛选素数，通过这种方法，我们可以高效地得到一个范围内的素数集合。当处理类似问题时，我们可以考虑使用试除法来判断是否为素数。\n","slug":"信息学奥赛-试除法：高效筛选素数的算法","date":"2022-08-01T08:44:57.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"}]