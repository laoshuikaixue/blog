[{"id":"042458818a0bf030644a59426600c495","title":"浙江学考信息技术学考复习要点","content":"01 信息基础理论DIKW模型\nD (Data - 数据): 对客观事物的符号表示，是原始的、未经处理的素材。\n例: 传感器读数、用户注册信息、交易记录。\n\n\nI (Information - 信息): 经过加工处理、具有特定含义的数据，用于消除不确定性。\n特征: 载体依附性、时效性、共享性、可加工处理性、真伪性、价值性。\n例: 根据传感器读数判断的“温度过高”警报、整理后的用户列表、月度销售报告。\n\n\nK (Knowledge - 知识): 经过归纳、总结、提炼的信息，形成规律性的认识，指导行动。\n例: “温度超过30度需要开空调”的规则、用户画像分析、销售趋势预测模型。\n\n\nW (Wisdom - 智慧): 对知识的综合运用、创新和决策能力，具有前瞻性。\n例: 基于对用户、市场、技术的综合理解，制定新的产品策略或优化运营方案。\n\n\n\n信息编码与数字化数制问题计算机内部以二进制 (B) 处理数据。常见进制还有八进制 (O)、十进制 (D)、十六进制 (H)。\n\n常见进制转换:\n\n十进制 → R进制: 除R取余法 (整数部分)，乘R取整法 (小数部分)。\nR进制 → 十进制: 按权相加法。\n二进制 ↔ 十六进制: 四位合一位 &#x2F; 一位拆四位。\n二进制 ↔ 八进制: 三位合一位 &#x2F; 一位拆三位。\n\n\n\n【24.7学考真题】 算式 (17)₁₀ + (11010)₂ 的运算结果是A. (101011)₂B. (110101)₂C. (27)₁₀D. (30)₁₀【答案】 A【解析】 (11010)₂ &#x3D; 1 * 2⁴ + 1 * 2³ + 0 * 2² + 1 * 2¹ + 0 * 2⁰ &#x3D; 16 + 8 + 0 + 2 + 0 &#x3D; (26)₁₀。(17)₁₀ + (26)₁₀ &#x3D; (43)₁₀。将 (43)₁₀ 转换为二进制:43 &#x2F; 2 &#x3D; 21 … 121 &#x2F; 2 &#x3D; 10 … 110 &#x2F; 2 &#x3D; 5  … 05 &#x2F; 2 &#x3D; 2  … 12 &#x2F; 2 &#x3D; 1  … 01 &#x2F; 2 &#x3D; 0  … 1倒序取余数得 (101011)₂。\n\n\n数字化将模拟信号转换为数字信号的过程。\n\n采样: 时间（或空间）上离散化。采样频率越高，信息损失越少，但数据量越大。\n量化: 幅值（或数值）上离散化。量化位数越多，精度越高，但数据量越大。\n编码: 将量化后的离散值用二进制代码表示。\n\n\n字符编码:\n\nASCII: 7位编码，扩展ASCII为8位 (1字节)，主要用于英文。\nGB2312&#x2F;GBK&#x2F;GB18030: 汉字编码标准，一个汉字通常占2字节。\nUnicode (UTF-8): 变长编码，兼容ASCII，能表示世界上几乎所有字符。\n\n\n存储单位:\n\n位 (bit, b): 最小单位。\n字节 (Byte, B): 基本单位，1 B &#x3D; 8 b。\nKB, MB, GB, TB… (1 KB &#x3D; 1024 B)\n\n\n【23.7学考真题】 下列关于该材料中数据与数据处理的说法，不正确的是(材料涉及手机导航，语音输入目的地)A. 火车票上的文字是数据的一种表现形式B. 大数据处理技术能增强导航服务的智能性C. 导航数据的可视化有利于观察和分析数据D. 用语音规划行程路线时无需对用户语音进行数字化【答案】 D【解析】 语音是模拟信号，计算机处理需要先进行采样、量化、编码，将其数字化。\n\n\n大数据的思维与处理\n特征 (4V):\nVolume (体量大)\nVelocity (速度快，实时性要求高)\nVariety (类型多：结构化、半结构化、非结构化)\nValue (价值密度低，需要挖掘)\n\n\n思维:\n分析全体数据，而非抽样。\n关注相关性，而非绝对的因果关系。\n接受数据的混杂性，而非追求精确。\n\n\n处理:\n基本思想：分治思想 (将大任务分解成小任务并行处理，最后汇总)。\n常见架构：批处理 (MapReduce)、流计算 (Storm, Flink)、图计算 (GraphX)。\n\n\n\n数据安全\n威胁: 硬件故障、操作失误、病毒感染、黑客攻击、自然灾害、内部泄露等。\n\n保障方法:\n\n物理安全: 环境控制、设备保护。\n数据备份: 定期备份、异地容灾。\n访问控制: 身份认证 (用户名密码、生物特征、UKey)、权限管理。\n数据加密: 对称加密、非对称加密。\n网络安全: 防火墙、入侵检测。\n安全意识: 规范操作、不共享账户、定期更换密码。\n\n\n【24.7学考真题】 为提升该系统数据的安全性, 下列措施不合理的是 (系统为公司打卡系统)A. 增强员工数据安全意识B. 让多个员工共享一个账户C. 对系统重要数据进行加密D. 为服务器配备不间断电源【答案】 B【解析】 共享账户无法明确责任人，是严重的安全隐患。\n\n\n人工智能 (AI)\n三大主义:\n\n符号主义 (基于规则): 模拟人类逻辑思维。关键词：知识库、推理引擎、专家系统、逻辑编程 (LISP, Prolog)。\n联结主义 (基于数据): 模仿大脑神经元连接。关键词：神经网络、深度学习、数据驱动、模式识别 (图像、语音)、大模型 (ChatGPT, AlphaGo)。\n行为主义 (基于交互): 模拟生物与环境交互。关键词：感知-行动、强化学习、试错、机器人。\n\n\n应用: 图像识别、语音识别、自然语言处理 (NLP)、推荐系统、自动驾驶、专家系统等。\n\n【24.7学考真题】 要提升无人驾驶配送车的智能水平, 下列措施不合理的是A. 完善系统对各类交通标志识别的训练B. 强化系统在与环境交互中的不断学习C. 持续迭代优化自动驾驶的算法D. 增加无人驾驶配送车的车厢容积【答案】 D【解析】 增加车厢容积属于物理结构改变，与提升智能水平（算法、学习能力）无关。选项A、B、C分别对应联结主义和行为主义的改进思路。\n\n\n02 Python基础代码及常见模块Python基础数据结构\n字符串 (str): 不可变序列。s = &#39;hello&#39;\n索引: s[0] (结果 ‘h’), s[-1] (结果 ‘o’)\n切片: s[1:4] (结果 ‘ell’), s[:3] (结果 ‘hel’), s[::2] (结果 ‘hlo’)\n常用方法: len(), + (连接), * (重复), str(), int(), float(), ord(), chr(), find(), replace(), split()\n\n\n列表 (list): 可变序列。 L = [1, &#39;a&#39;, 3.14, [1, 2]]\n索引、切片同字符串。\n修改: L[1] = &#39;b&#39;\n常用方法: append(), insert(), remove(), pop(), sort(), reverse(), len()\n\n\n字典 (dict): 键值对集合，无序 (Python 3.7+ 有序)，键唯一，可变。 d = &#123;&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 18&#125;\n取值: d[&#39;name&#39;] (结果 ‘Alice’)\n修改&#x2F;添加: d[&#39;age&#39;] = 19, d[&#39;city&#39;] = &#39;Hangzhou&#39;\n常用方法: keys(), values(), items(), get(), pop(), len()\n\n\n\nPython程序结构\n顺序结构: 按代码书写顺序执行。\n分支结构 (选择结构):\nif &lt;条件&gt;: &lt;语句块&gt;\nif &lt;条件&gt;: &lt;语句块1&gt; else: &lt;语句块2&gt;\nif &lt;条件1&gt;: &lt;语句块1&gt; elif &lt;条件2&gt;: &lt;语句块2&gt; ... else: &lt;语句块N&gt;\n\n\n循环结构:\nfor &lt;变量&gt; in &lt;序列&gt;: &lt;循环体&gt; (遍历序列)\nwhile &lt;条件&gt;: &lt;循环体&gt; (条件满足时循环)\nbreak: 跳出当前循环。\ncontinue: 跳过本次循环，进入下一次迭代。\nelse (用于循环): 循环正常结束 (非 break 跳出) 时执行。\n\n\n\n函数与模块的调用\n函数:\n\n内建函数: print(), input(), len(), int(), str(), float(), type(), ord(), chr(), range() 等。\n自定义函数: def func_name(param1, param2): ... return value\n\n\n模块:\n\n导入: import module_name, from module_name import function_name, import module_name as alias\n常用模块:\nmath: math.sqrt(), math.sin(), math.pi 等。\nrandom: random.random() (0到1随机浮点数), random.randint(a, b) (a到b随机整数), random.choice(seq) (序列随机选一个), random.shuffle(list) (原地打乱列表)。\npandas: 数据分析库 (见后文)。\nmatplotlib.pyplot: 数据可视化库 (见后文)。\n\n\n\n\n【24.7学考真题】 某 Python 程序如下:\n123456789s=input()k=0 ; n=0for x in s:   if &quot;a&quot;&lt;=x and x&lt;=&quot;g&quot;:      k=(ord(x)-ord(&quot;a&quot;)+5)%7+1   elif &quot;1&quot;&lt;=x and x&lt;=&quot;5&quot;:      n=int(x)keynum=n*7+kprint(keynum)\n程序运行时, 若输出为 28 , 则可能的输入是A. y9Ac4B. b3a4AC. a4kb3D. ha9k3【答案】 C【解析】 输出 keynum = n*7 + k = 28。因为 1 &lt;= k &lt;= 7，1 &lt;= n &lt;= 5。尝试可能的 n 值：若 n&#x3D;1, 7+k&#x3D;28, k&#x3D;21 (不可能)若 n&#x3D;2, 14+k&#x3D;28, k&#x3D;14 (不可能)若 n&#x3D;3, 21+k&#x3D;28, k&#x3D;7若 n&#x3D;4, 28+k&#x3D;28, k&#x3D;0 (不可能)所以必须 n&#x3D;3, k&#x3D;7。n&#x3D;3 要求输入字符串中最后一个数字字符是 ‘3’。k&#x3D;7 要求最后一个 a-g 范围内的字符 x 满足 (ord(x)-ord(&quot;a&quot;)+5)%7+1 = 7，即 (ord(x)-ord(&quot;a&quot;)+5)%7 = 6。测试选项C: 输入 “a4kb3”x&#x3D;’a’: k&#x3D;(ord(‘a’)-ord(‘a’)+5)%7+1 &#x3D; 5%7+1 &#x3D; 6x&#x3D;’4’: n&#x3D;4x&#x3D;’k’: 不在范围内，n, k 不变x&#x3D;’b’: k&#x3D;(ord(‘b’)-ord(‘a’)+5)%7+1 &#x3D; (1+5)%7+1 &#x3D; 6%7+1 &#x3D; 7x&#x3D;’3’: n&#x3D;3循环结束时 n&#x3D;3, k&#x3D;7。 keynum &#x3D; 3*7 + 7 &#x3D; 28。符合要求。\n\n\n03 进阶算法及其程序实现解析算法利用数学公式或逻辑推导直接求解。\n\n例: 计算圆面积 S = math.pi * r**2。求解一元二次方程。\n\n枚举算法 (穷举法)一一列举所有可能解，并验证是否满足条件。通常需要循环和判断。\n\n核心: 循环(列举) + 判断(验证)\n\n适用: 解空间有限且不大。\n\n优化: 剪枝 (提前排除不可能的分支)。\n\n【23.7学考真题】 某Python程序如下：\n1234567891011121314a=input(&quot;输入数字字符串：&quot;)s=&quot;&quot;flag=1for i in range(0, len(a)-1, 2): # 枚举下标i (0, 2, 4...)    dl=int(a[i])    d2=int(a[i+1])    t=dl+flag*d2         # 计算    if t&lt;0: t+=10        # 调整t到0-9    elif t&gt;=10: t-=10    s=str(t)+s           # 结果逆序拼接    flag=-flag           # flag在1和-1间切换if len(a)%2==1:          # 处理奇数长度的最后一个字符    s+=a[len(a)-1]       # 直接拼接到末尾 (注意不是逆序)print(s)\n程序运行时，若输入“48135”，则输出的结果是A. 528 B. 582 C. 825 D. 285【答案】 C【解析】输入 “48135”, len(a)&#x3D;5i&#x3D;0: d1&#x3D;4, d2&#x3D;8, flag&#x3D;1. t&#x3D;4+1*8&#x3D;12. t&gt;&#x3D;10, t&#x3D;12-10&#x3D;2. s&#x3D;”2”. flag&#x3D;-1.i&#x3D;2: d1&#x3D;1, d2&#x3D;3, flag&#x3D;-1. t&#x3D;1+(-1)*3&#x3D;-2. t&lt;0, t&#x3D;-2+10&#x3D;8. s&#x3D;”8”+”2”&#x3D;”82”. flag&#x3D;1.循环结束 (i&#x3D;4 不满足 &lt; len(a)-1)。len(a)%2 &#x3D;&#x3D; 1 (5%2&#x3D;1)，执行 s +&#x3D; a[len(a)-1]，即 s +&#x3D; a[4]。a[4] 是 ‘5’. s &#x3D; “82” + “5” &#x3D; “825”.输出 825。\n\n\n04 pandas + MatplotlibExcel与数据处理基础\n数据问题: 缺失、重复、异常 (离群值)、逻辑错误、格式不一。\n处理方法:\n缺失: 删除、填充 (均值、中位数、众数、模型预测)。\n重复: 识别并删除或合并。\n异常: 识别 (箱线图、统计规则) 并修正或删除。\n逻辑错误: 修正或删除。\n格式不一: 数据类型转换、单位统一。\n\n\n\npandas 核心对象\nSeries: 一维带标签数组。 s = pd.Series(data, index=index)\nDataFrame: 二维带标签表格型数据结构。 df = pd.DataFrame(data, index=index, columns=columns)\n\nDataFrame 常用操作\n创建&#x2F;读取:\n\npd.DataFrame(字典或列表)\npd.read_excel(&#39;filename.xlsx&#39;)\npd.read_csv(&#39;filename.csv&#39;)\n\n\n查看数据:\n\ndf.head(n): 查看前n行 (默认5)。\ndf.tail(n): 查看后n行 (默认5)。\ndf.shape: 查看形状 (行数, 列数)。\ndf.info(): 查看基本信息 (列名、非空值数、数据类型)。\ndf.describe(): 查看数值列的描述性统计。\n\n\n选取数据:\n\n选列: df[&#39;列名&#39;] (返回Series), df[[&#39;列名1&#39;, &#39;列名2&#39;]] (返回DataFrame)。\n选行:\n按标签 (索引): df.loc[行标签] 或 df.loc[行标签1:行标签N]\n按位置 (整数): df.iloc[行号] 或 df.iloc[行号1:行号N]\n\n\n选行列: df.loc[行标签, 列名], df.iloc[行号, 列号]\n条件选取: df[df[&#39;列名&#39;] &gt; value], df[ (df[&#39;列1&#39;]&gt;v1) &amp; (df[&#39;列2&#39;]==v2) ] (&amp;:与, |:或, ~:非)\n\n\n修改数据:\n\n直接赋值: df.loc[行标签, 列名] = new_value, df[&#39;列名&#39;] = new_values\n\n\n删除数据:\n\ndf.drop(labels, axis=0): 删除行 (axis&#x3D;0 默认)。 labels 为行索引列表。\ndf.drop(labels, axis=1): 删除列 (axis&#x3D;1)。 labels 为列名列表。\n\n\n排序:\n\ndf.sort_values(by=&#39;列名&#39;, ascending=True/False): 按值排序。\ndf.sort_index(ascending=True/False): 按索引排序。\n\n\n分组聚合:\n\ndf.groupby(&#39;分组列名&#39;).agg_function()\nagg_function 可以是 sum(), mean(), count(), size(), max(), min() 等。\ndf.groupby([&#39;列1&#39;, &#39;列2&#39;]).sum(): 按多列分组。\n\n\n【24.7学考真题】 某校学生的课外运动积分存储在文件 “jifen.xlsx” 中… 编写 Python 程序, 统计并输出积分大于100的高一01班学生信息。\n123456789import pandas as pddf1 = pd.read_excel(&quot;jifen.xlsx&quot;) # 读文件中的数据# --- 划线处代码 ---# ① df1=df1[df1.积分&gt;100]# ② df1=df1[df1.班级==&quot;高一01班&quot;]# ③ df1=df1.sort_values(&quot;积分&quot;,ascending=False) #降序排序# ④ df1= df1.head(100) #取前100条数据# --------------------print(df1)\n要实现上述功能，下列代码中正确的是A. ②① B. ②④ C. ③① D. ③④【答案】 A【解析】 需要筛选满足两个条件的行：1. 班级是”高一01班” (对应语句②)；2. 积分大于100 (对应语句①)。这两个筛选操作的顺序可以互换，②①或①②都可以。排序③和取前100条④与题目要求无关。\n\n\nMatplotlib 数据可视化\n导入: import matplotlib.pyplot as plt\n基本绘图:\nplt.plot(x, y): 折线图 (适合趋势变化)。\nplt.bar(x, height): 柱状图 (适合比较大小)。\nplt.barh(y, width): 条形图 (适合类别名较长时)。\nplt.scatter(x, y): 散点图 (适合变量间关系)。\nplt.pie(x, labels=labels, autopct=&#39;%1.1f%%&#39;): 饼图 (适合比例构成)。\n\n\n图表元素设置:\nplt.title(&#39;标题&#39;)\nplt.xlabel(&#39;X轴标签&#39;)\nplt.ylabel(&#39;Y轴标签&#39;)\nplt.xticks(ticks, labels): 设置X轴刻度。\nplt.yticks(): 设置Y轴刻度。\nplt.legend([&#39;图例1&#39;, &#39;图例2&#39;]): 显示图例。\nplt.grid(True): 显示网格线。\nplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]: 设置中文字体 (解决中文乱码)。\nplt.rcParams[&#39;axes.unicode_minus&#39;] = False: 解决负号显示问题。\n\n\n显示图表: plt.show()\n\n05 信息系统支撑技术信息系统组成与功能\n组成部分 (5部分):\n\n硬件 (Hardware): 计算机 (CPU, 内存, 存储器, 输入&#x2F;输出设备), 服务器, 网络设备 (路由器, 交换机), 传感设备, 智能终端等物理实体。\n软件 (Software):\n系统软件: 操作系统 (Windows, Linux, macOS), 数据库管理系统 (DBMS: MySQL, Oracle, SQL Server)。\n应用软件: 为特定目的开发的程序 (如学考报名系统, ERP, CRM)。\n\n\n数据 (Data): 系统处理的对象，存储在数据库中。\n网络 (Network): 连接硬件、传输数据的通信设施 (有线、无线、协议)。\n人员 (People): 用户、管理员、开发人员、维护人员等。\n\n\n功能: 数据采集、输入、传输、存储、处理、输出、控制、反馈。\n\n【24.7学考真题】 下列关于该系统组成与功能的说法, 正确的是 (系统为公司打卡系统, 通过人脸识别)A. 该系统的硬件仅指打卡机与服务器B. 该系统的用户只包括员工和管理员C. 该系统需要事先采集员工的人脸数据D. 该系统的出勤统计功能由打卡机完成【答案】 C【解析】 A错，还需要网络设备等；B错，可能还有开发维护人员；C对，人脸识别需要预先录入数据；D错，统计功能通常由服务器端的软件完成，打卡机主要负责采集和传输。\n\n\n网络概念与传输\n分类:\n按范围: 局域网 (LAN), 城域网 (MAN), 广域网 (WAN)。\n按介质: 有线网, 无线网。\n\n\n网络协议 (TCP&#x2F;IP):\n应用层: HTTP, FTP, SMTP, DNS 等 (定义应用程序如何交互)。\n传输层: TCP (可靠传输), UDP (不可靠但高效传输) (管理端到端的数据传输)。\n网络层 (网际层): IP (负责寻址和路由，将数据包从源送到目的地)。\n数据链路层: 负责物理介质上的数据帧传输 (如以太网协议)。\n物理层: 定义物理连接的电气、机械特性。\n\n\nIP地址: 标识网络中的设备，由网络号和主机号组成。IPv4 (32位), IPv6 (128位)。\n域名系统 (DNS): 将域名 (如 www.google.com) 解析为 IP 地址。\nURL (统一资源定位器): 协议://主机名[:端口号]/路径/文件名 (如 http://www.example.com:80/index.html)\n\n传感技术\n传感器: 检测物理量 (温度、湿度、光照、压力、声音、加速度等) 并将其转换为可用信号 (通常是电信号) 的装置。\n\n组成: 敏感元件 (感受被测量) + 转换元件 (转换成电信号) + 转换电路。\n\nRFID (射频识别): 无线通信技术，通过无线电讯号识别特定目标并读写相关数据。\n\n组成: 标签 (Tag, 存储信息)、读写器 (Reader)、天线。\n类型: 无源RFID (标签自身不带电，靠读写器能量激活)、有源RFID (标签自带电池)。\n\n\n【23.7学考真题】 有如下三个传感器的应用场景：(1)拍手时楼道内的灯自动点亮；(2)手机根据环境亮度自动调节屏幕亮度；(3)智能手环具有计步功能。为上述三个应用场景依次选择一种适用的传感器，下列选项正确的是A. 声音传感器、光线传感器、压力传感器B. 声音传感器、光线传感器、加速度传感器C. 压力传感器、距离传感器、光线传感器D. 光线传感器、声音传感器、加速度传感器【答案】 B【解析】 (1) 检测声音用声音传感器；(2) 检测亮度用光线传感器；(3) 计步通常通过检测运动状态变化，使用加速度传感器。\n\n\n信息系统安全 (补充)\n加密:\n对称加密: 加解密用同一密钥 (如 DES, AES)。优点：速度快。缺点：密钥分发困难。\n非对称加密: 公钥加密，私钥解密 (或私钥签名，公钥验证) (如 RSA)。优点：密钥分发安全。缺点：速度慢。\n\n\n数字签名: 利用非对称加密，用私钥对信息摘要进行加密，保证信息的完整性、身份认证和不可否认性。\n防火墙: 隔离内外网络，控制网络访问。\n\n信息系统架构\nC&#x2F;S (Client&#x2F;Server): 客户端需要安装专门软件，服务器提供服务。优点：性能好，界面丰富。缺点：开发维护更新成本高。\n\nB&#x2F;S (Browser&#x2F;Server): 客户端使用浏览器访问，主要逻辑在服务器。优点：部署维护更新方便。缺点：性能和用户体验可能受限。\n\n【23.7学考真题】 设计该系统的网络应用软件时，为方便软件的升级和维护，应选择的实现架构是 （单选，A.B&#x2F;S架构 B.C&#x2F;S架构）（题目背景是一个心率血压监测系统，用户通过手机APP查看）(注意：虽然手机APP是客户端，但现代APP常内嵌网页或通过API与Web服务器交互，很多后台系统偏向B&#x2F;S的维护便利性。不过，如果强调的是客户端软件本身，则C&#x2F;S特点更明显。此题答案可能依赖具体情境，但学考中通常将 易于维护升级 指向 B&#x2F;S架构，因为只需更新服务器端。）【推测答案】 A (基于“方便升级维护”通常指向B&#x2F;S的优点)\n\n\n06 信息系统硬件搭建与软件开发 (简述)开发过程\n系统规划: 可行性分析 (技术、经济、操作)。\n系统分析: 需求分析 (功能、性能、数据、安全)。产出物：数据流图、数据字典、需求规格说明书。\n系统设计:\n概要设计: 体系结构设计、模块划分、数据库设计。\n详细设计: 模块内部算法设计、数据库物理设计、界面设计。\n\n\n系统实施: 编码、硬件购买与安装、数据库建立、系统测试 (单元测试、集成测试、系统测试、验收测试)。\n系统运行与维护: 系统转换、日常维护、系统改进。\n\n智能硬件 (如 micro:bit, ESP32)\n集成了处理器、内存、输入&#x2F;输出引脚、通信模块 (蓝牙、Wi-Fi) 的微控制器板。\n可连接各种传感器和执行器。\n常用编程语言：MicroPython, C&#x2F;C++, 图形化编程。\n\nIoT (物联网)\n通过各种信息传感设备，将物品与互联网连接起来，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理。\n\n关键技术: 传感技术、网络通信技术 (Wi-Fi, 蓝牙, Zigbee, LoRa, NB-IoT, 5G)、云计算、大数据、人工智能。\n\n架构 (常见分层): 感知层 (数据采集)、网络层 (数据传输)、平台层 (数据处理存储)、应用层 (面向用户)。\n\n【23.7学考真题】 该系统的心率历史数据存储在 （单选，填字母：A.智能终端／B.服务器）中。 (系统为心率血压监测系统)【答案】 B【解析】 智能终端（如手环）通常只做短期存储或实时显示，历史数据、需要长期保存和分析的数据一般存储在服务器的数据库中。\n\n【23.7学考真题】 该系统服务器端程序采用Flask Web框架编写，若智能终端某次提交心率数据到服务器的URL为 http://192.168.0.20:8080/upload?val=76，则本次提交的心率值为_________。【答案】 76【解析】 URL中 ? 后面是查询参数，格式为 key=value。这里 val=76，表示参数 val 的值是 76，对应提交的心率值。\n\n\n","slug":"浙江学考信息技术学考复习要点","date":"2025-04-05T11:42:53.000Z","categories_index":"高中,数据与信息,编程,Python","tags_index":"教材学习,学考","author_index":"LaoShui"},{"id":"e762971b5e5d5706d967112712c93106","title":"信息技术 · 必修一 · 第一章 数据与信息 知识点","content":"当我写下这篇文章时 我正式开始了对高中信息技术教材的学习 我会在空闲时间不断补充内容\n数据是对客观事物的符号表示，如图形符号、数字、字母等。其中，数字是最简单的一种数据。单纯的数据是没有意义的，经过解释，数据才变得有意义。 人们在利用数据的同时，自身的行为也在产生数据。科学研究离不开数据。\n\n计算机科学中，数据是指所有能输入到计算机并被计算机程序处理的符号总称，其表现形式可以是文字、图形、图像、音频、视频等。\n\n信息的特征：\n\n载体依附性\n时效性\n共享性\n可加工处理性、真伪性\n价值性\n\n\n信息与载体区分：信息是看不见摸不着的。文字、图像、声音、二进制代码等都是信息的载体，文字、图像里面所表达的意思才是信息。\n\n信息是不能独立存在的，它的表示、传播、存储必须依附于载体(载体依附性)，不存在没有载体的信息。如果存储信息的载体遭到破坏，那么其承载的信息就会消失。信息可以脱离它所反映的事物被存储、保留和传播(但不能脱离载体)。\n\n信息往往反映的是事物某一特定时间内的状态，它会随着时间的推移而变化。\n\n信息是可以共享的，同一种信息可以同时被不同的接收者获取，人们也可以重复利用信息。与物质、能源不同的是，信息不会因为被别人获取而发生损耗。\n\n信息的价值也是相对的，对于不同的人群、不同的时间，其价值可能有所不同。\n\n数据、信息与知识的关系\n\n目前数据的获取方法以机器获取为主，传感器随时获取来自自然信源的数据，网络爬虫可在短时间内获取大量网络数据。 \n\n信息可用模拟信号或数字信号表达。模拟信号以连续变化的物理量存在，当字信号在取值上是离散的、不连续的信号。\n\n模拟信号与数字信号可以相互转换，其中将模拟信号转换为数字信号的过程称为数字化，通常需要经过采样、量化与编码三个步骤。每秒采样的样本数称为采样频率，单位为赫兹(Hz)。在采样过程中，提高采样频率可以减少失真并提升保真度。模拟信号经过采样后成为离散信号，随后通过量化将离散信号的连续取值近似为有限个离散值，并用数值表示。以声音数字化为例，声音信号通过麦克风转为电流信号，再经声卡上的模数转换器(ADC)将电流信号转为数字信号，经过采样、量化后进行编码并存储于计算机中。在重放时，数字信号通过数模转换器(DAC)还原为模拟信号，放大后送至扬声器发声。\n\n进制转换\n\n存储单位基础概念\n\n最小单位：位（bit，比特）表示二进制数的一位，取值为0或1。\n基本单位：字节（Byte）1 Byte &#x3D; 8 bits，是数据存储的基本单元。\n\n【单位换算关系】（二进制前缀体系）\n\n\n\n单位名称\n符号\n等价换算\n十进制近似值\n\n\n\n字节\nB\n1 B &#x3D; 8 bits\n-\n\n\n千字节\nKB\n1 KB &#x3D; 2¹⁰ B &#x3D; 1024 B\n≈ 10³ B\n\n\n兆字节\nMB\n1 MB &#x3D; 1024 KB\n≈ 10⁶ B\n\n\n吉字节\nGB\n1 GB &#x3D; 1024 MB\n≈ 10⁹ B\n\n\n太字节\nTB\n1 TB &#x3D; 1024 GB\n≈ 10¹² B\n\n\n拍字节\nPB\n1 PB &#x3D; 1024 TB\n≈ 10¹⁵ B\n\n\n\n\n\n\n\n\n\n特别注意\n\n存储设备厂商常采用十进制换算（1KB&#x3D;1000B），操作系统采用二进制换算，这是导致标称容量与实际显示容量差异的原因\n国际标准 IEC 60027-2 定义了明确区分：\n二进制单位：KiB（Kibibyte）、MiB（Mebibyte）等\n十进制单位：KB（Kilobyte）、MB（Megabyte）等\n\n\n典型容量认知：\n1页纯文本 ≈ 3KB\n1首MP3歌曲 ≈ 5MB\n1部高清电影 ≈ 2GB\n1TB硬盘可存储约25万张高清照片\n\n\n\n\n\n\n未压缩音频存储容量(B) &#x3D; 采样频率(赫兹) × 量化位数(比特) × 声道数 × 时间(秒) / 8;常见的声音文件类型有Wave、MP3、WMA等，其中Wave为未压缩格式。\n\n图像存储容量计算\n公式： 图像容量(B) = 水平像素 × 垂直像素 × 位深度 / 8其中：\n\n位深度：每个像素占用的二进制位数（决定颜色表现范围）\n分辨率：水平像素 × 垂直像素（总像素数量）\n\n分辨率 800×600 图像容量计算\n\n\n\nBMP图像类型\n位深度\n容量计算公式（bit位）\n计算结果（B字节）\n换算为常用单位\n\n\n\n黑白二值图\n1位\n800×600×1&#x2F;8\n60,000 B\n~58.6 KB\n\n\n灰度&#x2F;256色彩图\n8位\n800×600×8&#x2F;8\n480,000 B\n~468.75 KB\n\n\n高彩色（增强色）\n16位\n800×600×16&#x2F;8\n960,000 B\n~937.5 KB\n\n\n真彩色\n24位\n800×600×24&#x2F;8\n1,440,000 B\n~1.37 MB\n\n\n真彩色+透明度\n32位\n800×600×32&#x2F;8\n1,920,000 B\n~1.83 MB\n\n\n关键知识点扩展\n\n位深度与颜色关系\n1位：2色（黑白）\n8位：256色（灰度或调色板索引）\n16位：65,536色（高彩色，如 RGB 5-6-5 模式）\n24位：16,777,216色（真彩色，RGB 8-8-8）\n32位：24位真彩色 + 8位透明度通道（RGBA）\n\n\n**色和位的转换。n位 可以表示 2ⁿ 色。如256色(级)就是8位\n\n\n视频存储容量计算公式\n\n公式一（通过单帧计算）视频存储容量(B) = 单帧图像存储量 × 帧频 × 播放时间(秒) / 8其中：单帧图像存储量 = 水平像素 × 垂直像素 × 每个像素所占位数（bit）\n公式二（直接像素计算）视频存储容量(B) = 水平像素 × 垂直像素 × 每个像素位数 × 帧频 × 播放时间(秒) / 8\n压缩视频计算公式（了解即可 考试应该不考）容量(B) = 比特率(bps) × 时间(s) / 8（注：比特率单位为bits per second，需注意kbps&#x3D;1000bps的十进制换算）\n\n\n\n\n\n\n\n\n特别注意\n\n电视广播制式影响 | 2023年12月16日 影视飓风的视频中有提及\n\nPAL标准（中国广播电视的标准）：25帧&#x2F;秒\nNTSC标准：29.97帧&#x2F;秒（通常简化为30帧&#x2F;秒计算）\n\n\n公式适用范围\n\n前两公式适用于未压缩视频（如AVI RAW）\n压缩视频（如MP4、H.264）需用比特率计算，且实际容量受编码效率影响\n\n\n深度关联因素\n\n分辨率：高清(1920×1080) vs 4K(3840×2160) 容量差异显著\n色彩模式：RGB 24bit（1677万色）比8位灰度容量大3倍\n\n\n典型场景参考\n\n1分钟1080P@25fps未压缩视频 ≈1920×1080×24bit×25×60 /8 = 93,312,000 B ≈ 89.1 MB\n同规格H.265压缩视频（码率5Mbps）≈5,000,000×60 /8 = 37,500,000 B ≈ 35.8 MB\n\n\n\n\n\n\n数字图像包括矢量图形与位图图像。\n\n矢量图形核心特性定义矢量图形由数学方程描述的几何元素构成，包括：- 基本元素：点、直线、曲线、多边形- 绘制方式：通过坐标、曲率参数等数学属性定义图形关键特征对比（与位图对比）  \n\n\n\n特性\n矢量图形\n位图（栅格图像）\n\n\n\n构成原理\n数学方程绘制\n像素点阵排列\n\n\n文件大小\n通常较小（仅存储参数）\n较大（存储所有像素信息）\n\n\n缩放性能\n无限放大无失真\n放大后出现马赛克&#x2F;模糊\n\n\n适用场景\n标志设计、工程制图、字体\n照片、复杂渐变色图像\n\n\n编辑特性\n独立修改元素属性\n需修改像素区域\n\n\n\n\n\n\n\n\n技术细节延伸\n\n数学描述示例\n\n圆形：(x-a)² + (y-b)² = r²（中心坐标(a,b)，半径r）\n贝塞尔曲线：通过控制点参数方程生成平滑曲线\n\n\n分辨率无关性原理  \n\n图形在渲染时实时计算数学方程，输出始终匹配显示设备的最佳分辨率\n\n\n典型文件格式\n\n.svg (Scalable Vector Graphics)\n.ai (Adobe Illustrator)\n.eps (Encapsulated PostScript)\n\n\n复杂度与性能关系\n\n1,000个简单几何图形 ≈ 100KB\n50,000节点复杂矢量图 ≈ 3MB（仍远小于同尺寸位图）\n\n\n\n\n\n\n\n\n\n\n\n\n特别注意\n重要局限性\n\n自然场景局限  \n\n不擅长表现照片级真实感图像（如皮肤纹理、云层渐变）\n\n\n渲染消耗计算资源  \n\n超复杂矢量图（如3D CAD图纸）需要高性能GPU实时渲染\n\n\n格式转换风险  \n\n矢量图转位图时需指定分辨率，一旦转换将丢失可编辑特性\n\n\n色彩表现限制  \n\n传统矢量图形对渐变色处理能力弱于位图（现代工具已改善）\n\n\n\n\n\n工程应用实例\n\nAutoCAD施工图：DWG格式文件可在不同缩放级别保持尺寸精度\n企业VI系统：矢量LOGO可适配从名片到户外广告牌的任意尺寸\n字体设计：TTF&#x2F;OTF字体通过贝塞尔曲线定义字符轮廓\n\n\n信息编码：两种颜色，可以采用1位二进制编码：0和1。四种颜色可以采用2位二进制编码：00、01、10、11。总结：n位可以表示2ⁿ种不同的编码。\n\n\n","slug":"信息技术-·-必修一-·-第一章-数据与信息-知识点","date":"2024-12-13T10:06:22.000Z","categories_index":"高中,必修一,数据与信息,编程,Python","tags_index":"教材学习","author_index":"LaoShui"},{"id":"c0cbd51e6cc6162b96e9aed7b5281420","title":"开源：升学E网通绕过会员以及点击检测（已失效）","content":"开源地址：https://github.com/laoshuikaixue/ewt360/\newt360前言\n\n\n\n\n\n\n\n\n请不要滥用此仓库中的内容ewt有时可能会做更新，程序不保证一定能用  \n目前实现的功能\n 绕过点击检测\n 绕过点击检测（无数据上报 慎用）\n\n使用说明\n绕过会员检测\n此功能用于观看视频出现此提示的绕过 你需要安装油猴脚本插件 安装方法请自行上网搜索\n随后添加这个脚本：https://greasyfork.org/zh-CN/scripts/500965-ewt360-permission-interceptor 即可绕过\n原理：\n\n拦截返回内容 修改这部分内容 对播放器进行欺骗\n\n绕过点击检测：首先 打开视频页面\n随后 打开浏览器的DevTools（按F12或右键 这里推荐使用EDGE以及谷歌浏览器）\n\n找到此JS 右键点击 点击替代内容（如果没有 请更换上述推荐浏览器并检查浏览器版本）\n在文件导航对话框中，选择本地计算机上的一个文件夹来存储要替换的资源文件，例如 C:\\Users\\myusername\\overrides，然后单击 选择文件夹 按钮\nDevTools 警告你必须具有对该文件夹的完全访问权限，并且不应泄露任何敏感信息\n单击 允许 按钮 随后在打开的页面中粘贴项目中txt文本内的内容（JS加密了 可能会无响应 可以修改后缀后直接替换掉这个文件）\n随后刷新一次页面 弹出\n\n即代表加载成功 随后关闭DevTools 即可播放视频\n注意：此操作会导致教师后台无点击通过率数据 谨慎使用注意：如果你需要加载补丁 你需要每次打开页面的时候都打开DevTools进行一次刷新操作\n\n推荐的同类项目\n刷课+自动完成选择题的工具箱 刷课+自动完成选择题的工具箱（油猴脚本）\n刷课+自动完成选择题的工具箱 上述脚本开源地址  \newt360 Python实现刷e网通假期课程进度（停止维护）\n\n后言此仓库内容仅供学习参考使用 学习后请立即删除 因使用者产生的个人问题与本仓库开发者无关\n禁止滥用本仓库的内容 若进行二开请严格遵守license 严禁各类商业行为\n若发现失效等情况 请在仓库的issues中或下方评论区（匿名邮箱不予回复 回了你也收不到）提出 并欢迎PR\n","slug":"开源：升学E网通绕过会员以及点击检测","date":"2024-07-18T07:37:54.000Z","categories_index":"开源,编程","tags_index":"官方","author_index":"LaoShui"},{"id":"d06e89d326c3b959da197d0b11709006","title":"探索2FA双因素认证与TOTP时间同步一次性密码","content":"2FA (Two-Factor Authentication) 与 TOTP (Time-Based One-Time Password)引言在当今数字化时代，信息安全的重要性日益凸显，传统的单一密码登录方式已经无法满足高效且安全的身份验证需求。因此，双因素认证（2FA, Two-Factor Authentication）应运而生，作为一项关键的安全措施，它要求用户提供两个独立的证明身份的方式，显著提高了账户安全性。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是2FA中的一个重要实现方案。\n什么是2FA（双因素认证）双因素认证（2FA）是一种多层次的身份验证机制，旨在确保只有授权用户能够访问受保护的资源。根据NIST（美国国家标准与技术研究院）的定义，它结合了以下至少两种认证因素：\n\n知识因素：只有用户知道的信息，如密码、PIN码或者安全问题的答案；\n所有权因素：用户拥有的物理设备或虚拟凭证，如智能手机、USB令牌、短信验证码或生物特征；\n内在因素：用户固有的生物特征，如指纹、面部识别或虹膜扫描。\n\nTOTP（时间同步一次性密码）原理TOTP 是2FA的一个具体实现，它基于时间的一次性密码算法。在这个机制下，用户和服务器双方共同持有预先共享的秘密密钥。每隔一段固定的时间间隔（通常为30秒），双方都会根据当前时间戳和此密钥通过HMAC（Hash-based Message Authentication Code）算法计算出一个唯一的、短暂有效的动态密码。\n工作流程\n密钥生成与存储：\n\n用户在启用TOTP时，会生成一个基于特定算法的密钥，并将其保存在服务器端和用户端（通常是手机上的认证APP）。\n\n\n时间同步：\n\nTOTP算法依赖于时间同步，客户端和服务端各自基于当前时间戳计算哈希值。\n\n\n密码生成：\n\n使用HMAC函数，将当前时间戳与共享密钥相结合生成一个哈希值。\n从哈希值中抽取一定长度的数值作为一次性密码。\n\n\n验证过程：\n\n当用户尝试登录时，在认证APP上获取并输入当前的有效TOTP密码。\n服务器同样根据当前时间戳计算TOTP密码，并与用户提交的密码进行比对，如果匹配，则验证成功。\n\n\n\n总归来说，使用 TOTP 来进行 2FA 的第一步就是通过 QRCode Server 让跟 Client(App) 约定好一个秘密，之后就都用那个秘密跟接下来的时间来进行 Hash 。我们就按这个流程来评估每个步骤的安全性。\n结论TOTP作为双因素认证的重要组成部分，不仅强化了传统密码体系，而且在实施过程中具有简单易用、成本低廉的特点。随着越来越多的在线服务提供商采用2FA和TOTP，这种基于时间的一次性密码技术已经成为提升账户安全性的主流手段之一。无论是企业级应用还是个人用户，启用TOTP能够有效抵御诸如网络钓鱼、密码猜测等常见安全威胁，保障数字资产和个人信息安全。\n","slug":"探索2FA双因素认证与TOTP时间同步一次性密码","date":"2024-03-02T04:06:33.000Z","categories_index":"编程,安全","tags_index":"官方","author_index":"LaoShui"},{"id":"70c15220323e313ec6083d38a84c2668","title":"Python 快速排序：原理、使用场景与实现方法","content":"引言快速排序（Quick Sort）是由英国计算机科学家托尼·霍尔于1960年提出的一种高效的排序算法。其主要特点在于采用了分治策略，通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n一、快速排序原理\n选择基准元素：首先在待排序数组中选取一个基准元素（通常选择第一个或最后一个元素，也可以采用随机选择的方式以提高平均性能）。\n\n分区操作：重新排列数组，使得基准元素之前的所有元素都不大于它，之后的所有元素都不小于它。这个过程称为分区操作，可以通过两个指针从两端向中间移动，并交换不满足条件的元素位置来完成。\n\n递归排序：然后分别对基准元素左侧和右侧的子数组进行快速排序，直至所有子数组只有一个元素或者为空。\n\n\n二、快速排序步骤详解假设有一个无序数组[5, 3, 8, 6, 7, 2]，按照快速排序的过程：\n\n选择基准元素：我们选择第一个元素5作为基准。\n分区操作：\n从右向左找到第一个小于基准的元素2，从左向右找到第一个大于基准的元素8，交换它们的位置，得到[2, 3, 5, 6, 7, 8]\n继续左右扫描，交换5和3，得到最终分区结果[2, 3, 5, 6, 7, 8]，此时基准元素位于正确位置\n\n\n递归排序：\n对[2, 3]子数组进行快速排序\n对[6, 7, 8]子数组进行快速排序\n\n\n\n三、快速排序代码实现以下是一个简单的快速排序实现：\n1234567891011121314def quick_sort(arr):    if len(arr) &lt;= 1:        return arr        pivot = arr[len(arr) // 2]    left = [x for x in arr if x &lt; pivot]    middle = [x for x in arr if x == pivot]    right = [x for x in arr if x &gt; pivot]        return quick_sort(left) + middle + quick_sort(right)# 示例调用unsorted_array = [5, 3, 8, 6, 7, 2]sorted_array = quick_sort(unsorted_array)\n\n四、快速排序的使用场景\n大规模数据排序：由于快速排序的平均时间复杂度为O(n log n)，对于大规模数据排序任务，快速排序具有较高的效率，尤其是在内部实现优化后，如“三数取中法”选择基准等技巧，能进一步提升性能。\n教育示例：快速排序展示了分治策略在解决问题上的强大威力，是学习、竞赛中广泛使用的经典实例。\n实际应用：在很多编程语言的标准库中，快速排序被用于实现数组和列表的排序功能，例如C++ STL中的std::sort函数就采用了快速排序及其改进版。\n\n需要注意的是，在最坏情况下，当输入数据已经完全有序或逆序时，快速排序的时间复杂度会退化到O(n²)，但这种情况在实际应用中相对较少见。为了规避这一问题，可以采用随机化选择基准元素的方法，使算法在概率意义下有较好的表现。\n","slug":"Python-快速排序：原理、使用场景与实现方法","date":"2024-02-09T08:31:40.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"0425545bbf78488183c9b7bbe87131db","title":"Python 插入排序：原理、使用场景与实现方法","content":"引言插入排序（Insertion Sort）是一种简单直观且易于理解的排序算法，其工作原理类似于我们手动整理扑克牌的过程。通过构建一个有序序列，每次从未排序部分中取出一个元素并将其插入到已排序序列的正确位置，直到整个序列有序。尽管在处理大规模数据时效率较低，但对于小规模数据或部分有序的数据集，插入排序表现出了较好的性能。\n\n一、插入排序原理\n构建初始有序序列：首先将数组的第一个元素视为已排序序列。\n逐个插入：从第二个元素开始，依次与已排序序列中的元素进行比较，找到合适的插入位置，并将其插入。\n重复上述过程：继续对剩余未排序元素执行相同的操作，直至所有元素都已排序到位。\n\n二、插入排序步骤详解假设有一个无序数组[5, 3, 8, 6, 7, 2]，按照插入排序的过程：\n\n第一轮：\n\n数组的第一个元素默认为已排序部分，即[5]\n将第二个元素3与5进行比较，发现3小于5，所以将3插入到5之前，得到[3, 5]\n\n\n第二轮：\n\n已排序部分为[3, 5]\n将第三个元素8与已排序部分的元素依次比较，无需移动，得到[3, 5, 8]\n\n\n继续这个过程，直到所有元素都已排序。\n\n\n三、插入排序代码实现以下是一个简单的插入排序实现：\n12345678910111213141516def insertion_sort(arr):    n = len(arr)        # 遍历数组中的每个元素    for i in range(1, n):        current = arr[i]        j = i - 1                # 将当前元素与其左侧的已排序元素进行比较和交换        while j &gt;= 0 and arr[j] &gt; current:            arr[j + 1] = arr[j]            j -= 1                    arr[j + 1] = current            return arr\n\n四、插入排序的使用场景\n小规模数据集：对于数据量较小的情况，插入排序可以快速完成排序任务，尤其是当数据近乎有序时，其时间复杂度接近O(n)。\n在部分场景下的优化：例如，当待排序数据基本有序时，插入排序能有效减少元素之间的比较次数，从而提高排序效率。\n\n插入排序的时间复杂度达到O(n²)，因此插入排序也并非首选方案。\n","slug":"Python-插入排序：原理、使用场景与实现方法","date":"2024-02-09T08:27:12.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"0490642c71381612a7160eef78d1d327","title":"Python 选择排序：原理、使用场景与实现方法","content":"引言选择排序（Selection Sort）是一种简单直观的排序算法，其主要思想是通过不断遍历待排序序列，并在每次遍历时找出剩余未排序部分中的最小（或最大）元素，将其放到已排序序列的末尾。虽然选择排序的时间复杂度并不优秀，但它简洁易懂的逻辑使其成为初学者理解排序算法的理想起点。\n\n一、选择排序原理选择排序的基本步骤如下：\n\n寻找最小值：首先从待排序的数组中选出最小（或最大）的元素。\n交换位置：将找到的最小元素与数组的第一个未排序元素交换位置，此时第一个元素为已排序区间的最后一个元素。\n重复上述过程：接着在剩余的未排序序列中重复寻找最小元素并交换的过程，直至整个序列有序。\n\n二、选择排序步骤详解假设有一个无序数组[5, 3, 8, 6, 7, 2]，按照选择排序的过程：\n\n第一轮：\n\n在所有未排序元素中找到最小值2，并与数组的第一个元素交换位置，得到[2, 3, 8, 6, 7, 5]\n\n\n第二轮：\n\n在剩下的未排序元素[3, 8, 6, 7, 5]中找到最小值3，与当前未排序区间的第一个元素交换位置，得到[2, 3, 8, 6, 7, 5]（这里无需交换，因为3已经位于正确位置）\n\n\n继续这个过程，直到所有元素都已排序。\n\n\n三、选择排序代码实现以下是一个简单的选择排序实现：\n123456789101112131415def selection_sort(arr):    n = len(arr)        # 遍历所有数组元素    for i in range(n):        # 找到剩余未排序部分中的最小元素索引        min_index = i        for j in range(i + 1, n):            if arr[j] &lt; arr[min_index]:                min_index = j                        # 将找到的最小元素与未排序区间的第一个元素交换        arr[i], arr[min_index] = arr[min_index], arr[i]            return arr\n\n四、选择排序的使用场景尽管选择排序通常不是最优选择，但在特定场景下仍有一定的实用价值：\n\n稳定性需求：选择排序是一种稳定的排序算法，即相等的元素在排序后相对顺序保持不变，这在处理具有特殊稳定性需求的问题时可能有优势。\n数据量较小且对效率要求不高的场合：对于小规模数据集或者对运行速度要求不苛刻的应用场景，选择排序可以作为一个简单的解决方案。\n\n然而，选择排序的时间复杂度始终为O(n²)，其性能远不如快速排序、归并排序和堆排序等高效算法。因此，在实际开发、竞赛中，尤其是在对效率有较高要求的情况下，选择排序并非首选方案。\n","slug":"Python-选择排序：原理、使用场景与实现方法","date":"2024-02-09T08:16:22.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"5a1ed4bfdc47ff55e285206610294889","title":"Python 冒泡排序：原理、使用场景与实现方法","content":"引言冒泡排序（Bubble Sort）是一种简单直观的排序算法，因其运作机制类似于水中的气泡不断向上浮起而得名。虽然在实际应用中，冒泡排序通常不是最优选择，但其原理清晰易懂，常被用作学习和理解排序算法的基础，对于初学者有着重要的教育价值。\n\n一、冒泡排序原理冒泡排序的基本思想是通过不断交换相邻两个元素的位置，使较大的元素逐渐“浮”到序列的末尾，每一轮循环都会将当前未排序序列中的最大（或最小）元素“冒泡”至正确位置。\n\n比较并交换过程：从数组的第一个元素开始，每次遍历都将相邻的元素两两进行比较，如果前一个元素大于后一个元素，则交换它们的位置。\n重复上述过程：每完成一次遍历（即一趟冒泡），最后一个元素将是当前未排序部分的最大值。因此，需要重复此过程n-1次，以确保整个数组完全有序。\n\n二、冒泡排序步骤详解假设有一个无序数组[5, 3, 8, 6, 7, 2]，按照冒泡排序的过程：\n\n第一轮冒泡：\n\n比较并交换5和3，得到[3, 5, 8, 6, 7, 2]\n比较并交换5和8，得到[3, 5, 8, 6, 7, 2]（无需交换）\n…\n比较并交换7和2，得到[3, 5, 6, 7, 2, 8]\n\n\n第二轮冒泡：\n\n比较并交换3和5，得到[3, 5, 6, 7, 2, 8]（无需交换）\n…\n比较并交换6和2，得到[3, 5, 6, 2, 7, 8]\n\n\n继续这个过程，直到所有元素都已排序。\n\n\n三、冒泡排序代码实现以下是一个简单的冒泡排序实现：\n1234567891011121314151617181920def bubble_sort(arr):    n = len(arr)        # 遍历所有数组元素    for i in range(n):        # 提前退出标志，表示已经有序        swapped = False                # 对每轮剩下的元素进行遍历        for j in range(0, n - i - 1):            # 如果前一个元素比后一个元素大，则交换它们            if arr[j] &gt; arr[j + 1]:                arr[j], arr[j + 1] = arr[j + 1], arr[j]                swapped = True                        # 如果本轮没有发生过交换，说明已经有序，提前退出        if not swapped:            break                return arr\n\n四、冒泡排序的使用场景尽管冒泡排序在处理大规模数据时效率较低，但它在特定场景下仍有实用价值：\n\n小规模或基本有序的数据集：当待排序的数据量较小，或者数据近乎有序时，冒泡排序可能具有相对较好的性能表现。\n简化版优化：例如，在每一轮冒泡过程中增加一个标记来判断是否发生交换，若没有发生则提前结束排序，这种改进后的冒泡排序对近乎有序的数组有较好效果。\n\n","slug":"Python-冒泡排序：原理、使用场景与实现方法","date":"2024-02-09T08:11:13.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"21aab6d167e8b8f08f85d33c3f085939","title":"时间复杂度在编程中的应用与实例分析","content":"引言时间复杂度是对算法运行时间的理论分析工具，它揭示了随着输入数据规模n的增长，算法执行所需时间的变化趋势。本文将详细探讨四种常见的时间复杂度类型：常数阶O(1)、线性阶O(n)、对数阶O(log n)以及平方阶O(n^2)，并结合代码实例进行深入解析。\n一、常数阶时间复杂度 O(1)定义：常数阶时间复杂度表示无论输入数据规模如何变化，算法运行所需时间基本保持不变。\n实例分析：\n12def constant_time_operation(data):    return data[0]  # 不论data列表长度为多少，获取第一个元素的操作都是固定时间的\n在这个例子中，不论data列表有多长，获取第一个元素的时间是恒定的，因此该函数的时间复杂度为O(1)。\n二、线性阶时间复杂度 O(n)定义：线性阶时间复杂度表明算法的运行时间与输入数据规模成正比关系，数据规模每增加一个单位，运行时间也会相应地增加一个基本单位。\n实例分析：\n1234def linear_time_operation(data):    for item in data:        # 对data中的每个元素执行某项操作        pass\n上述代码遍历了一个列表或链表的所有元素，对于长度为n的数据结构，需要执行n次操作，所以其时间复杂度为O(n)。\n三、对数阶时间复杂度 O(log n)定义：对数阶时间复杂度意味着当数据规模翻倍时，所需时间仅增长一个单位。这种效率在处理大规模数据时表现优秀。\n实例分析：以二分查找为例\n12345678910111213141516def binary_search(data, target):    low, high = 0, len(data) - 1        while low &lt;= high:        mid = (low + high) // 2        if data[mid] == target:            return mid        elif data[mid] &lt; target:            low = mid + 1        else:            high = mid - 1                return -1  # 如果未找到目标值则返回-1# 在排序后的数组中查找目标值binary_search(sorted_data, target)\n在二分查找中，每次比较都将搜索范围缩小一半，因此在最坏情况下，查找长度为n的已排序数组中的元素所需次数最多为log2(n)，故此函数的时间复杂度为O(log n)。\n四、平方阶时间复杂度 O(n^2)定义：平方阶时间复杂度意味着算法的运行时间与输入数据规模的平方成正比，当数据规模增大时，计算时间会急剧增加。\n实例分析：以冒泡排序为例\n123456789def bubble_sort(data):    n = len(data)        for i in range(n):        for j in range(0, n - i - 1):            if data[j] &gt; data[j + 1]:                data[j], data[j + 1] = data[j + 1], data[j]                    return data\n冒泡排序通过两层循环完成排序，外层循环次数为n，内层循环次数随外层循环递减，但最大仍为n次。因此，在最坏的情况下，总共进行了n * (n-1)&#x2F;2次比较和交换，时间复杂度为O(n^2)。\n总结来说，理解和掌握不同时间复杂度的概念及其对应的典型算法，有助于我们在编程实践中选择最优解法，合理的时间复杂度分析能有效提升程序性能和解题效率。\n","slug":"时间复杂度在编程中的应用与实例分析","date":"2024-02-08T12:30:04.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"389b18851d712cc1db6a774e37294354","title":"竞赛编程中分析时间复杂度与空间复杂度的重要性","content":"引言在竞赛编程领域，高效且准确的算法是决胜的关键。而衡量一个算法优劣的重要指标，便是其时间和空间复杂度。本文将深入探讨在竞赛编程中如何理解和分析时间复杂度与空间复杂度，以及它们对于优化代码性能、提升解题效率的重要性。\n一、时间复杂度1. 定义时间复杂度是对算法运行时间的量化度量，它描述的是问题规模n增大时，算法执行时间的增长速度。通常用大O符号（Big O notation）表示，例如：O(1)，O(n)，O(log n)，O(n^2)等。\n2. 分析方法\n常数阶时间复杂度 O(1)：无论输入数据规模如何，算法运行的时间基本保持不变。\n线性阶时间复杂度 O(n)：算法运行时间与输入数据规模成正比，如遍历数组或链表。\n对数阶时间复杂度 O(log n)：二分查找、堆排序等算法在处理大量数据时表现出优秀的效率。\n平方阶时间复杂度 O(n^2)：如冒泡排序、选择排序等，当数据规模增大时，计算时间急剧增加。\n\n在竞赛中，我们通常会选择时间复杂度低的算法以保证程序能在规定时间内完成求解。\n二、空间复杂度1. 定义空间复杂度是指算法在运行过程中临时占用存储空间大小的增长趋势，同样使用大O符号表示。\n2. 分析方法\n常数阶空间复杂度 O(1)：算法所需额外空间不随输入数据规模增大而增大，比如大部分数学运算函数。\n线性阶空间复杂度 O(n)：算法所需空间与输入数据规模成正比，如动态规划中的数组存储状态，或者深度优先搜索过程中的递归栈。\n对数阶、指数阶等其他复杂度：根据具体情况，可能需要考虑更复杂的空间消耗模型。\n\n在某些限制内存使用的竞赛题目中，降低空间复杂度尤为重要，避免因内存溢出而导致程序崩溃。\n三、实战应用在实际竞赛编程中，理解并熟练运用时间复杂度和空间复杂度分析，能够帮助我们：\n\n快速识别并排除明显效率较低的解题方案；\n在多种解法中选取最优策略，特别是在大规模数据场景下；\n设计更为精巧的算法，提高代码运行效率；\n预估程序性能，合理安排代码结构，防止超时或内存溢出。\n\n接下来的文章会详细介绍这些算法的优劣和使用方法\n","slug":"竞赛编程中分析时间复杂度与空间复杂度的重要性","date":"2024-02-08T10:41:34.000Z","categories_index":"编程","tags_index":"官方","author_index":"LaoShui"},{"id":"1ce36757e3e88b272b7c9f6027d9ece0","title":"基于函数计算3.0 Stable Diffusion Serverless API 的AI艺术字头像生成应用搭建与实践的报告","content":"随着AIGC技术的热度持续升高，AI绘画以其独特创新的艺术表现力吸引了广泛的关注，我通过利用阿里云函数计算团队开发的基于Stable Diffusion Serverless API解决方案，搭建了一套能够满足多场景需求的高性能、易部署和可扩展的AI艺术字头像生成平台。\n利用Stable Diffusion Serverless API强大的并发能力，多个请求可以并行处理，显著提高出图效率。用户还可以通过高级设置调整文字内容、字体、颜色、位置大小等细节参数，以及Stable Diffusion模型本身的渲染选项如迭代步数、提示词、反向提示词等，快速生成具有艺术特色的AI文字头像，尤其适合在春节期间进行分享展示。\n实验过程中 使用了如下阿里云服务：\n函数计算 FC（Function Compute）对象存储 OSS表格存储 Tablestore\n实验后，真实感受到了阿里云函数计算FC 3.0的全托管、事件驱动特性使整个应用轻量灵活，易于集成和扩展。未来，随着AIGC技术不断进步，此类Serverless解决方案将为更多开发者提供便捷的工具链和服务环境，进一步推动AI绘画技术在各行业中的创新应用和商业化落地。\n\n\n\n\n\n","slug":"基于函数计算3-0-Stable-Diffusion-Serverless-API-的AI艺术字头像生成应用搭建与实践的报告","date":"2024-02-08T10:10:35.000Z","categories_index":"编程,fc AIGC,Serverless,人工智能,函数计算","tags_index":"官方","author_index":"LaoShui"},{"id":"d474c339b16bd4b2fa6459002b26491b","title":"Python OJ题典型算法：字符型数据与ASCII码详解","content":"介绍本文将介绍字符型数据与ASCII码的相关知识点。\n解析在计算机中，字符型数据与ASCII码密切相关。ASCII（American Standard Code for Information Interchange）是一种用于表示文本字符的编码方式。\n解题思路要理解字符型数据与ASCII码之间的关系，我们首先需要了解ASCII码的基本概念和原理。\nASCII码使用7位二进制数（即128个不同的值）来表示所有的可打印字符、控制字符以及一些特殊字符。每个字符都有一个对应的唯一的ASCII码。\n在字符串中，每个字符都可以用一个ASCII码来表示。例如，字符’A’对应的ASCII码是65，字符’a’对应的ASCII码是97。\n代码实现下面是一个示例代码，演示了如何将字符转换为对应的ASCII码：\n12345678# 输入一个字符char = input(&quot;请输入一个字符：&quot;)# 使用ord()函数获取字符的ASCII码ascii_code = ord(char)# 输出ASCII码print(&quot;字符&quot;, char, &quot;的ASCII码是：&quot;, ascii_code)\n\n测试示例假设输入的字符是：’A’\n输出：\n1字符 A 的ASCII码是： 65\n\n解题技巧\n要记住ASCII码中常见字符的对应关系，可以通过查看ASCII码表或使用编程语言提供的内置函数来获取。\n可以使用ord()函数将字符转换为对应的ASCII码，使用chr()函数将ASCII码转换为对应的字符。\n在处理字符串时，需要注意字符编码的问题，尤其是当涉及到不同编码方式（如Unicode）时。\n\n总结本文介绍了字符型数据与ASCII码的关系，以及如何将字符转换为对应的ASCII码。通过理解和掌握这些知识点，我们可以在编程中更方便地处理字符型数据，并进行相关的操作。\n","slug":"Python-OJ题典型算法：字符型数据与ASCII码详解","date":"2024-01-20T14:47:10.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"c7d0ccfa3f344c02b0cc5d43076d420e","title":"Python OJ题：快速求出现次数最多的数字","content":"例题问题描述景区在售票时，从游客身份证中提取了年龄信息。现在，景区管理员想知道，按年龄统计，游客数量最多的是什么年龄？\n输入只有一行，n 个游客年龄数据，数据为整数，两个数据之间有一个空格\n输出第一行：输出最多游客数量的年龄，相同数量的，优先输出年龄大的\n第二行：输出最多游客的数量\n样例135 40 80 40 40 40 35 40 15 20\n\n12405\n\n\n分析要解决这道题，我们只需要创建一个列表，记录游客的年龄信息，然后找到列表中元素出现的频次，并找出出现次数最多的元素及其对应的出现次数\n那么我们可以通过Python collections 模块中的 Counter 类来快速找到列表中出现最多的数字\nCounter 是一个字典子类，用于计数可哈希对象（如本题中列表中的元素）的数量\n实现我们首先创建一个 Counter 对象 c，通过传入列表 lst 进行初始化。在这个过程中，Counter 对 lst 中的所有元素进行计数，结果是一个字典，其中键是列表中的元素，值是它们在列表中出现的次数\n1c = Counter(lst)\n\n然后使用 Counter 的 most_common() 方法获取出现次数最多的元素。most_common() 方法返回一个列表，其中包含元组，每个元组包含一个元素及其出现次数，按出现次数从高到低排序\n12c.most_common(1)[0][0]c.most_common(1)[0][1]\n\n\nc.most_common(1) 表示我们只需要出现次数最多的那一个元素及其出现次数，因此传入参数 1\n\n[0][0] 和 [0][1] 分别用于获取这个元组的第一个和第二个元素，也就是出现次数最多的元素及其对应的出现次数\n\n\n再将出现次数最多的元素赋值给变量 a，出现次数赋值给变量 b\n12a = c.most_common(1)[0][0]b = c.most_common(1)[0][1]\n\n最后，分别打印出出现次数最多的元素 a 和其对应的出现次数 b\n12print(a)print(b)\n\n但要注意的是，本题中要求相同数量的，优先输出年龄大的。而使用这种方法会优先输出年龄小的，所以我们需要做一些改变\n代码示例1234567891011121314from collections import Counterlst = list(map(int, input().split()))c = Counter(lst)max_count = max(c.values())max_ages = [age for age, count in c.items() if count == max_count]max_ages.sort(reverse=True)a = max_ages[0]b = max_countprint(a)print(b)","slug":"Python-OJ题：快速求出现次数最多的数字","date":"2024-01-11T14:45:34.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"53f16d3eee15b742a4cfb37b3a93125a","title":"Python OJ题经典字符串操作——大小写转换","content":"题目介绍给定一个字符串，要求将其中的大写字母转换为小写字母，同时将小写字母转换为大写字母，并返回转换后的字符串。\n题目解析我们需要实现一个函数，接受一个字符串作为输入，然后对字符串进行大小写转换并返回结果。可以使用内置函数str.swapcase()来实现大小写转换。\n解题思路\n定义一个函数，接受一个字符串作为参数。\n使用str.swapcase()方法对字符串进行大小写转换。\n返回转换后的字符串。\n\n代码实现12345def swap_case(string):    return string.swapcase()# 测试示例print(swap_case(&#x27;Hello, World!&#x27;))  # 输出：hELLO, wORLD!\n\n解题技巧\nPython中可以使用str.swapcase()方法来进行大小写转换，非常简便。\n大小写转换是很常见的字符串处理操作，能够帮助我们快速进行字符串的格式调整。\n\n总结通过本题，我们了解到了如何使用Python中的str.swapcase()方法来对字符串进行大小写转换。这个方法非常方便，在实际开发中可以用于各种字符串处理场景。熟练掌握字符串操作可以提高编程效率，是每个开发者必备的基础技能。\n","slug":"Python-OJ题经典字符串操作——大小写转换","date":"2023-08-01T08:52:23.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"5bde76cf410436941caa57581e05a9eb","title":"信息学奥赛 如何在整数数组中寻找两数之和等于给定目标值","content":"题目介绍在一个整数数组中，找出两个数之和等于给定目标值。假设每个输入只有一个解，并且同一个元素不能使用两次。\n题目解析给定一个整数数组 nums 和一个目标值 target，要求返回数组中满足两数之和等于目标值的两个数的索引。\n解题思路一种简单的解法是使用两层循环遍历数组中的每对元素，判断它们的和是否等于目标值。这种解法的时间复杂度为 O(n²)。\n更高效的解法是利用哈希表。我们可以遍历一次数组，将每个元素与其索引存储在哈希表中。然后再遍历一次数组，对于每个元素，计算目标值与当前元素的差值，并检查这个差值是否在哈希表中。如果存在，则找到了两个数的索引。这种解法的时间复杂度为 O(n)。\n代码实现1234567def twoSum(nums, target):    hashmap = &#123;&#125;    for i, num in enumerate(nums):        complement = target - num        if complement in hashmap:            return [hashmap[complement], i]        hashmap[num] = i\n\n解题技巧\n使用哈希表可以将寻找目标值的时间复杂度从 O(n) 降低到 O(1)。\n\n总结本文介绍了在一个整数数组中寻找两个数之和等于给定目标值的方法。通过使用哈希表，我们可以以更高效的方式解决这个问题。当然，在解题时需注意题目中的约束条件，例如每个输入只有一个解，同一个元素不能使用两次等。\n","slug":"信息学奥赛-如何在整数数组中寻找两数之和等于给定目标值","date":"2023-08-01T08:49:28.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"58c7dcee11106804fdb10b6d10e556f9","title":"Python OJ题典例：判断回文串","content":"题目介绍这是一个经典的字符串处理问题。给定一个字符串，要求判断它是否是回文串。回文串是指正序和倒序读都一样的字符串。\n题目解析对于给定的字符串，我们需要判断它是否是回文串。回文串具有以下特点：\n\n字符串长度为奇数时，中间的字符可以忽略，对称位置的字符相同。\n字符串长度为偶数时，对称位置的字符相同。\n\n解题思路为了判断一个字符串是否是回文串，我们可以采用以下步骤：\n\n假设字符串的长度为n。\n使用两个指针，分别指向字符串的首位和末位。\n比较两个指针指向的字符，如果相同，则继续向中间移动，直到两个指针相遇或者不相同。\n如果两个指针相遇，则说明该字符串是回文串；如果两个指针不相同，则说明该字符串不是回文串。\n\n代码实现123456789101112131415def is_palindrome(s):    left = 0    right = len(s) - 1        while left &lt; right:        if s[left] != s[right]:            return False        left += 1        right -= 1        return True    # 测试示例print(is_palindrome(&quot;level&quot;))  # 输出：Trueprint(is_palindrome(&quot;hello&quot;))  # 输出：False\n\n解题技巧\n在比较字符时，可以使用ASCII码进行比较，提高比较效率。\n可以将字符串转换成小写或大写字母后再进行比较，忽略大小写的差异。\n\n总结通过使用双指针的方法，我们可以高效地判断一个字符串是否是回文串。这种解法的时间复杂度为O(n)，其中n是字符串的长度。在实际应用中，我们可以利用该方法来解决一些涉及字符串处理的问题。 \n","slug":"Python-OJ题典例：判断回文串","date":"2023-08-01T08:47:00.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"a6ce43f330920306cdee8f98cd33fefd","title":"解密经典数学问题：跳马问题的DFS解法","content":"题目介绍跳马问题是一个经典的数学问题，它涉及到一个马在棋盘上跳跃的路径规划。马在国际象棋中的走法是以字母表示，例如“D3”表示从位置D3跳到下一个位置。在跳马问题中，我们需要找到一条路径，使得马能够经过棋盘上的每个位置恰好一次。\n题目解析给定一个n x m的棋盘，我们需要找到一条路径，使得马能够从任意起始位置开始，经过每个位置恰好一次，并且最后回到起始位置。这是一个非常有趣且具挑战性的问题，它可以通过深度优先搜索（DFS）来解决。\n解题思路\n首先，我们定义一个n x m的棋盘，并用一个二维数组表示每个位置的访问情况。\n然后，我们选择一个起始位置作为DFS的起点，并将该位置标记为已访问。\n在DFS的过程中，我们检查当前位置的周围未访问的位置，并计算它们的可行度。\n可行度是指该位置周围未访问的位置的数量。我们可以根据可行度对周围位置进行排序，以便选择下一步要跳到的位置。\n选择下一步要跳到的位置后，我们进行递归调用DFS，并将该位置标记为已访问。\n重复上述步骤，直到所有的位置都被访问过。\n最后，我们判断最后一个位置是否能够与起始位置相连，如果可以，则说明找到了一条路径。\n\n代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def valid_moves(pos, board, visited):    # 计算当前位置的可行度    count = 0    for move in [(2, -1), (2, 1), (-2, -1), (-2, 1), (-1, 2), (-1, -2), (1, 2), (1, -2)]:        x = pos[0] + move[0]        y = pos[1] + move[1]        if 0 &lt;= x &lt; len(board) and 0 &lt;= y &lt; len(board[0]) and not visited[x][y]:            count += 1    return countdef dfs(pos, moves, board, visited):    visited[pos[0]][pos[1]] = True    moves.append(pos)        if len(moves) == len(board) * len(board[0]):        return True        next_moves = []    for move in [(2, -1), (2, 1), (-2, -1), (-2, 1), (-1, 2), (-1, -2), (1, 2), (1, -2)]:        x = pos[0] + move[0]        y = pos[1] + move[1]        if 0 &lt;= x &lt; len(board) and 0 &lt;= y &lt; len(board[0]) and not visited[x][y]:            next_moves.append((x, y))        next_moves.sort(key=lambda move: valid_moves(move, board, visited))        for move in next_moves:        if dfs(move, moves, board, visited):            return True        moves.pop()    visited[pos[0]][pos[1]] = False    return Falsedef solve(board):    n = len(board)    m = len(board[0])    visited = [[False for _ in range(m)] for _ in range(n)]        for i in range(n):        for j in range(m):            moves = []            if dfs((i, j), moves, board, visited):                return moves        return []# 测试示例board = [[0, 0, 0, 0],          [0, 0, 0, 0],         [0, 0, 0, 0]]moves = solve(board)for move in moves:    print(move)\n\n解题技巧\n在DFS的过程中，我们可以根据马在当前位置的可行度来选择下一步要跳到的位置，这样可以提高搜索效率。\n可以使用剪枝技巧来减少不必要的搜索。例如，如果一个位置已经被访问过，我们可以直接跳过该位置，不再进行递归调用。\n\n总结跳马问题是一个有趣且具挑战性的问题，通过深度优先搜索算法可以解决。本文介绍了题目的背景和解析，给出了一种基于DFS的解题思路，并提供了相应的代码实现。通过合理选择下一步要跳到的位置和使用剪枝技巧，我们可以高效地找到一条满足条件的路径。\n","slug":"解密经典数学问题：跳马问题的DFS解法","date":"2023-08-01T08:42:48.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"},{"id":"32b2866d3e9af05b26a9546f73f441fc","title":"信息学奥赛 试除法：高效筛选素数的算法","content":"题目介绍素数是指只能被1和自身整除的正整数，例如2、3、5、7等。现在给定一个范围内的整数序列，你需要编写一个算法来筛选出其中的素数。\n题目解析题目要求我们从给定的整数序列中筛选出素数。我们需要设计一个算法来判断一个数是否为素数，并将素数添加到结果集合中。\n解题思路为了判断一个数是否为素数，我们可以使用试除法。对于一个待判断的数x，我们从2开始，一直试除到sqrt(x)为止。如果在这个过程中发现x可被某个数整除，则x不是素数；否则x是素数。\n具体的算法如下：\n\n定义一个空集合result，用于存储筛选出的素数。\n对于每个待判断的数x，从2开始循环到sqrt(x)，判断x是否能够被这些数整除。\n如果x不能被任何数整除，则将x添加到result集合中。\n循环结束后，返回result作为结果。\n\n代码实现12345678910111213141516171819202122import mathdef sieve_of_eratosthenes(n):    primes = []    is_prime = [True] * (n + 1)    is_prime[0] = is_prime[1] = False    for i in range(2, int(math.sqrt(n)) + 1):        if is_prime[i]:            for j in range(i * i, n + 1, i):                is_prime[j] = False    for i in range(2, n + 1):        if is_prime[i]:            primes.append(i)    return primes# 测试示例n = 100result = sieve_of_eratosthenes(n)print(result)\n\n解题技巧\n在试除法中，我们只需要循环到sqrt(x)即可，因为如果存在大于sqrt(x)的因子，那么一定存在小于sqrt(x)的因子。\n使用一个布尔数组is_prime来记录每个数是否为素数，初始化为True，然后依次将非素数位置的值置为False，这样可以避免重复判断和减少计算量。\n\n总结本文介绍了如何使用试除法筛选素数，通过这种方法，我们可以高效地得到一个范围内的素数集合。当处理类似问题时，我们可以考虑使用试除法来判断是否为素数。\n","slug":"信息学奥赛-试除法：高效筛选素数的算法","date":"2022-08-01T08:44:57.000Z","categories_index":"编程,Python","tags_index":"官方","author_index":"LaoShui"}]